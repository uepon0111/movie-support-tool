<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>新しいページ - 動画再生支援ツール</title>

  <!-- favicon 等は index と同様にしておきます（存在しない場合はブラウザのデフォルト） -->
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png" />
  <link rel="shortcut icon" href="favicon.ico" />

  <!-- index と同じ CSS を取り込み（サイドパネルの位置・動作を一致させるため） -->
  <style>
    :root{
      --ctrl-size: clamp(34px, 5.5vw, 72px);
      --ctrl-padding-x: calc(var(--ctrl-size) * 0.22);
      --ctrl-padding-y: calc(var(--ctrl-size) * 0.16);
      --ctrl-font: calc(var(--ctrl-size) * 0.28);
      --ctrl-radius: calc(var(--ctrl-size) * 0.18);
      --hist-scale: 0.78;
      --hist-size: calc(var(--ctrl-size) * var(--hist-scale));
      --hist-padding-x: calc(var(--hist-size) * 0.18);
      --hist-font: calc(var(--hist-size) * 0.28);
      --hist-radius: calc(var(--hist-size) * 0.16);
      --tag-font: calc(var(--hist-font) * 0.9);
      --tag-padding-y: 4px;
      --tag-padding-x: 8px;
      --tag-radius: 8px;
      --ctrl-compact-scale: 0.72;
    }
    /* 背景色を白に変更（ユーザー要望） */
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans JP',Helvetica,Arial;Overflow:hidden;background:#ffffff;color:#111}
    .center{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      padding:24px;
      box-sizing:border-box;
      gap:16px;
    }
    .btn{appearance:none;border:0;padding:10px 12px;border-radius:10px;box-shadow:0 1px 4px rgba(0,0,0,.12);cursor:pointer;background:#fff}
    .primary{background:#0b74ff;color:white}
    .muted{background:#f0f0f0;color:#111}
    #panelToggleBtn {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 1200;
      height: calc(var(--ctrl-size) * 0.60);
      min-width: calc(var(--ctrl-size) * 0.60);
      padding: 0 calc(var(--ctrl-padding-x) * 0.6);
      font-size: calc(var(--ctrl-font) * 0.80);
      border-radius: calc(var(--ctrl-radius) * 0.9);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
    }
    /* ===== キャッシュ進捗オーバーレイ ===== */
    .cache-overlay {
      position: fixed;
      left: 50%;
      top: 18px;
      transform: translateX(-50%);
      z-index: 1400;
      min-width: 320px;
      max-width: 94%;
      background: rgba(255,255,255,0.98);
      color: #111;
      border-radius: 10px;
      box-shadow: 0 8px 28px rgba(0,0,0,0.24);
      padding: 12px;
      display: none;
      align-items: center;
      gap: 12px;
      box-sizing:border-box;
      border: 1px solid #e6f0ff;
    }
    .cache-overlay[aria-hidden="false"] { display:flex; }
    .cache-overlay .status {
      flex: 1;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .cache-overlay .status .title { font-weight:700; font-size:14px; color:#08345f; }
    .cache-overlay .status .msg { font-size:13px; color:#425565; }
    .cache-overlay .progress-bg {
      width: 100%;
      height: 10px;
      background: #eef6ff;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    .cache-overlay .progress-fill {
      position: absolute;
      left: 0; top: 0; bottom: 0;
      width: 0%;
      background: linear-gradient(90deg,#43a2ff,#0b74ff);
      transition: width 220ms linear;
    }
    .cache-overlay .actions { display:flex; gap:8px; align-items:center; }
    .cache-overlay .actions .btn { height:34px; padding:6px 10px; min-width:80px; }
    /* ===== サイドパネル ===== */
    .panel-backdrop {
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.32);
      z-index: 1280;
      display: none;
      -webkit-tap-highlight-color: transparent;
    }
    .panel-backdrop.show { display: block; }
    .side-panel {
      position: fixed;
      top: 0;
      bottom: 0;
      left: -340px; /* closed */
      width: 320px;
      max-width: 92%;
      background: #fff;
      color: #111;
      z-index: 1290;
      box-shadow: 6px 0 28px rgba(0,0,0,0.36);
      transition: left .26s cubic-bezier(.2,.8,.2,1);
      padding: 16px;
      box-sizing: border-box;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .side-panel.open { left: 0; }
    .side-panel .panel-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:12px;
    }
    .side-panel h3 { margin:0; font-size:16px; color:#08345f; }
    .side-panel .panel-close {
      appearance:none;border:0;background:transparent;font-size:18px;cursor:pointer;padding:6px;border-radius:8px;
    }
    .side-panel .panel-content { color:#111; }
    /* side panel のボタンを少し整える */
    .side-panel .panel-content .btn { display:block; width:100%; text-align:left; margin-bottom:8px; }
    .side-panel a.side-link { display:block; padding:10px 12px; border-radius:8px; text-decoration:none; color:inherit; background:#f8f9fb; margin-bottom:8px; }
    /* 小画面対応 */
    @media (max-width:480px){
      .side-panel { width: 86%; left: -92%; }
      .side-panel.open { left: 0; }
      .cache-overlay { left: 4%; transform: none; width: 92%; }
    }
  </style>
</head>
<body>
  <!-- 左上: サイドパネル開閉ボタン -->
  <button id="panelToggleBtn" class="btn muted" type="button" title="サイドパネルを開く" aria-label="サイドパネルを開く">☰</button>

  <!-- サイドパネル用バックドロップ（クリックで閉じる） -->
  <div id="panelBackdrop" class="panel-backdrop" aria-hidden="true"></div>

  <!-- サイドパネル（デフォルト閉） -->
  <aside id="sidePanel" class="side-panel" aria-hidden="true" role="dialog" aria-label="サイドパネル">
    <div class="panel-header">
      <h3>メニュー</h3>
      <button id="panelCloseBtn" class="panel-close" aria-label="閉じる">✕</button>
    </div>
    <div class="panel-content">
      <!-- Home: index.html に戻る -->
      <a href="index.html" class="side-link" id="homeLink" title="ホームに戻る">ホーム</a>

      <!-- Current: Newpage（このページ） -->
      <a href="newpage.html" class="side-link" id="newpageLink" title="このページ">新しいページ</a>

      <!-- キャッシュ削除ボタン（index と同じ ID を使っているので動作が類似） -->
      <button id="clearCacheBtn" class="btn muted" type="button" title="アプリ内キャッシュを削除します" aria-label="アプリ内キャッシュを削除">キャッシュ削除</button>

      <div style="margin-top:8px;color:#666;font-size:13px">
        キャッシュ削除ボタンは IndexedDB と Cache Storage を削除します。操作は元に戻せません。
      </div>
    </div>
  </aside>

  <!-- キャッシュ削除時の進捗オーバーレイ -->
  <div id="cacheOverlay" class="cache-overlay" aria-hidden="true">
    <div class="status">
      <div class="title" id="cacheOverlayTitle">キャッシュを削除しています…</div>
      <div class="msg" id="cacheOverlayMsg">準備中</div>
      <div class="progress-bg" aria-hidden="true">
        <div id="cacheProgressFill" class="progress-fill" style="width:0%"></div>
      </div>
    </div>
    <div class="actions">
      <button id="cacheCancelBtn" class="btn muted" type="button">キャンセル</button>
      <button id="cacheCloseBtn" class="btn muted" type="button" style="display:none">閉じる</button>
    </div>
  </div>

  <!-- ページ主要コンテンツ -->
  <main id="mainContent" class="center" style="color:#111; text-align:center;">
    <h1 style="margin:0 0 8px">新しいページ</h1>
    <p style="margin:0 0 16px;color:#666">ここは新しいページです。サイドパネルは index と同じ位置・動作をするようにしています。</p>
    <p style="color:#666">「ホーム」リンクで元ページ（index.html）に戻ります。</p>
    <p><a href="index.html" class="btn muted" style="text-decoration:none;color:inherit;">ホームに戻る</a></p>
  </main>

  <script>
    // サイドパネル要素
    const panelToggleBtn = document.getElementById('panelToggleBtn');
    const sidePanel = document.getElementById('sidePanel');
    const panelBackdrop = document.getElementById('panelBackdrop');
    const panelCloseBtn = document.getElementById('panelCloseBtn');

    // キャッシュ削除要素
    const clearCacheBtn = document.getElementById('clearCacheBtn');
    const cacheOverlay = document.getElementById('cacheOverlay');
    const cacheOverlayTitle = document.getElementById('cacheOverlayTitle');
    const cacheOverlayMsg = document.getElementById('cacheOverlayMsg');
    const cacheProgressFill = document.getElementById('cacheProgressFill');
    const cacheCancelBtn = document.getElementById('cacheCancelBtn');
    const cacheCloseBtn = document.getElementById('cacheCloseBtn');

    // DB 名は index と合わせる（index 側が同じ DB を使っている場合に整合）
    const DB_NAME = 'videoHistory';
    const STORE_NAME = 'videos';
    const META_STORE = 'entryMeta';

    // パネル開閉ロジック（index と同様の挙動）
    function openPanel(){
      sidePanel.classList.add('open');
      sidePanel.setAttribute('aria-hidden','false');
      panelBackdrop.classList.add('show');
      panelBackdrop.setAttribute('aria-hidden','false');
      panelToggleBtn.title = 'サイドパネルを閉じる';
      panelToggleBtn.setAttribute('aria-pressed', 'true');
    }
    function closePanel(){
      sidePanel.classList.remove('open');
      sidePanel.setAttribute('aria-hidden','true');
      panelBackdrop.classList.remove('show');
      panelBackdrop.setAttribute('aria-hidden','true');
      panelToggleBtn.title = 'サイドパネルを開く';
      panelToggleBtn.setAttribute('aria-pressed', 'false');
    }
    function togglePanel(){
      if (sidePanel.classList.contains('open')) closePanel();
      else openPanel();
    }
    panelToggleBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePanel(); });
    panelCloseBtn.addEventListener('click', (e)=>{ e.stopPropagation(); closePanel(); });
    panelBackdrop.addEventListener('click', (e) => { closePanel(); });
    sidePanel.addEventListener('click', (e) => { e.stopPropagation(); });

    // ユーティリティ: IndexedDB の全エントリを配列で取得する（store が存在しなければ空配列）
    function promisifyRequest(req){
      return new Promise((resolve,reject)=>{
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    function getAllFromStoreGeneric(db, storeName){
      return new Promise((resolve, reject) => {
        try {
          if (!db.objectStoreNames.contains(storeName)) return resolve([]);
          const tx = db.transaction(storeName, 'readonly');
          const store = tx.objectStore(storeName);
          const r = store.getAll();
          r.onsuccess = () => resolve(r.result || []);
          r.onerror = () => resolve([]);
        } catch (e) {
          resolve([]);
        }
      });
    }

    // 詳細な IndexedDB 削除 (進捗をコールバックで返す) — index と似た段階的削除を行う
    async function clearIndexedDBDetailed(controller, updateProgress) {
      // updateProgress(pct, msg)
      try {
        updateProgress(10, 'IndexedDB をオープンしています…');
        // try to open db to enumerate
        let db = null;
        try {
          db = await new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
            // onblocked ignored for enumeration
          });
        } catch (err) {
          db = null;
        }
        if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
        if (!db) {
          updateProgress(30, 'IndexedDB をオープンできません。データベース削除を試みます…');
          // fallback: deleteDatabase directly
          await new Promise((resolve, reject) => {
            try {
              const delReq = indexedDB.deleteDatabase(DB_NAME);
              delReq.onsuccess = () => resolve();
              delReq.onerror = () => reject(delReq.error);
              delReq.onblocked = () => resolve();
            } catch (err) { reject(err); }
          });
          return;
        }
        // enumerate stores
        const storesToCheck = [];
        if (db.objectStoreNames.contains(STORE_NAME)) storesToCheck.push(STORE_NAME);
        if (db.objectStoreNames.contains(META_STORE)) storesToCheck.push(META_STORE);
        let allEntries = [];
        for (const sname of storesToCheck) {
          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(35, `"${sname}" のエントリを取得しています…`);
          const items = await getAllFromStoreGeneric(db, sname);
          if (Array.isArray(items) && items.length > 0) {
            const annotated = items.map(it => ({ store: sname, item: it }));
            allEntries = allEntries.concat(annotated);
          }
        }
        if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
        const total = allEntries.length;
        if (total === 0) {
          updateProgress(55, '削除するエントリはありません。DB を削除します…');
        } else {
          updateProgress(45, `エントリを削除中… (0 / ${total})`);
          const batchSize = 10;
          for (let i = 0; i < allEntries.length; i += batchSize) {
            if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
            const slice = allEntries.slice(i, i + batchSize);
            const groups = {};
            slice.forEach(x => { groups[x.store] = groups[x.store] || []; groups[x.store].push(x.item); });
            for (const sname of Object.keys(groups)) {
              const tx2 = db.transaction(sname, 'readwrite');
              const store2 = tx2.objectStore(sname);
              for (const itemObj of groups[sname]) {
                try {
                  const id = (itemObj && itemObj.id != null) ? itemObj.id : (itemObj && itemObj.key != null ? itemObj.key : null);
                  if (id != null) {
                    try { store2.delete(Number(id)); } catch(e){ try { store2.delete(id); } catch(e){} }
                  }
                } catch (e) { /* ignore per-item delete error */ }
              }
              // await tx complete
              await new Promise(res => {
                tx2.oncomplete = () => res();
                tx2.onerror = () => res();
                tx2.onabort = () => res();
              });
            }
            const deleted = Math.min(total, i + batchSize);
            const base = 45;
            const span = 30;
            const pct = base + Math.round((deleted / Math.max(1, total)) * span);
            updateProgress(pct, `エントリを削除中… (${deleted} / ${total})`);
            await new Promise(r=>setTimeout(r, 60));
          }
        }
        try { db.close(); } catch(e){}
        if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
        updateProgress(80, 'データベースを完全に削除しています…');
        await new Promise((resolve, reject) => {
          try {
            const delReq = indexedDB.deleteDatabase(DB_NAME);
            delReq.onsuccess = () => resolve();
            delReq.onerror = () => reject(delReq.error);
            delReq.onblocked = () => resolve();
          } catch (err) { reject(err); }
        });
        updateProgress(92, 'IndexedDB の削除が完了しました（最終調整中）…');
        await new Promise(r=>setTimeout(r, 120));
        return;
      } catch (err) {
        if (err && err.name === 'AbortError') throw err;
        throw err;
      }
    }

    // clearCache 挙動（進捗オーバーレイ表示・キャンセル可能）
    if (clearCacheBtn) {
      clearCacheBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (!confirm('アプリ内のキャッシュ（保存された動画データなど）を完全に削除しますか？ この操作は元に戻せません。')) return;

        const controller = { aborted: false };
        cacheOverlay.setAttribute('aria-hidden', 'false');
        cacheOverlayTitle.textContent = 'キャッシュを削除しています…';
        cacheOverlayMsg.textContent = '準備中';
        cacheProgressFill.style.width = '6%';
        cacheCancelBtn.disabled = false;
        cacheCloseBtn.style.display = 'none';

        const onCancel = () => {
          controller.aborted = true;
          cacheOverlayMsg.textContent = 'キャンセル中…処理を停止します';
          cacheCancelBtn.disabled = true;
        };
        cacheCancelBtn.addEventListener('click', onCancel, { once: true });

        function updateProgress(pct, msg) {
          try { cacheProgressFill.style.width = Math.max(0, Math.min(100, Math.round(pct))) + '%'; } catch(e){}
          if (msg) cacheOverlayMsg.textContent = msg;
        }

        try {
          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(6, '準備しています...');
          await new Promise(r=>setTimeout(r, 140));

          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(18, '保留中のアップロードを中止しています...');
          // In this page there's no uploadControllers map; this step is kept for parity with index.
          await new Promise(r=>setTimeout(r, 160));

          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(30, 'IndexedDB の削除準備をしています...');
          try {
            await clearIndexedDBDetailed(controller, updateProgress);
          } catch (err) {
            if (err && err.name === 'AbortError') throw err;
            // fallback attempt: direct deleteDatabase
            try {
              await new Promise((resolve, reject) => {
                try {
                  const delReq = indexedDB.deleteDatabase(DB_NAME);
                  delReq.onsuccess = () => resolve();
                  delReq.onerror = () => reject(delReq.error);
                  delReq.onblocked = () => resolve();
                } catch (err2) { reject(err2); }
              });
            } catch (err2) {
              console.warn('fallback deleteDatabase failed', err2);
            }
          }

          await new Promise(r=>setTimeout(r, 180));
          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(68, 'Cache Storage を削除しています...');
          if ('caches' in window) {
            try {
              const keys = await caches.keys();
              let i = 0;
              for (const k of keys) {
                if (controller.aborted) break;
                await caches.delete(k);
                i++;
                const sub = 68 + Math.min(20, Math.round((i / Math.max(1, keys.length)) * 20));
                updateProgress(sub, `Cache "${k}" を削除中…`);
              }
            } catch (e) {
              console.warn('Cache Storage clear failed', e);
            }
          }

          await new Promise(r=>setTimeout(r, 120));
          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(92, 'ユーザーインターフェースを更新しています...');
          await new Promise(r=>setTimeout(r, 140));
          updateProgress(100, '完了しました');
          cacheOverlayMsg.textContent = 'キャッシュを削除しました';
          cacheCancelBtn.style.display = 'none';
          cacheCloseBtn.style.display = '';
          cacheCloseBtn.disabled = false;
          cacheCloseBtn.addEventListener('click', () => {
            cacheOverlay.setAttribute('aria-hidden', 'true');
          }, { once: true });

          alert('アプリのキャッシュ（IndexedDB と Cache Storage）を削除しました。');
        } catch (err) {
          if (err && err.name === 'AbortError') {
            updateProgress(0, '処理はキャンセルされました');
            cacheCancelBtn.style.display = 'none';
            cacheCloseBtn.style.display = '';
            cacheCloseBtn.disabled = false;
            cacheCloseBtn.addEventListener('click', () => {
              cacheOverlay.setAttribute('aria-hidden', 'true');
            }, { once: true });
            alert('キャッシュ削除はキャンセルされました。途中まで行われた処理は取り消せません。');
          } else {
            console.warn('clearCache error', err);
            updateProgress(100, 'エラーが発生しました');
            cacheCancelBtn.style.display = 'none';
            cacheCloseBtn.style.display = '';
            cacheCloseBtn.disabled = false;
            cacheCloseBtn.addEventListener('click', () => {
              cacheOverlay.setAttribute('aria-hidden', 'true');
            }, { once: true });
            alert('キャッシュ削除中にエラーが発生しました: ' + (err && err.message ? err.message : 'Unknown'));
          }
        } finally {
          try { cacheCancelBtn.removeEventListener('click', onCancel); } catch(e){}
        }
      });
    }

    // ページの外側クリックや ESC でパネルを閉じる（ちょっと補助）
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (sidePanel.classList.contains('open')) closePanel();
        if (cacheOverlay && cacheOverlay.getAttribute('aria-hidden') === 'false') {
          // do nothing to allow explicit close via overlay's ボタン
        }
      }
    });

    // 初期状態の調整（パネルは閉）
    (function init(){
      closePanel();
      try {
        cacheOverlay.setAttribute('aria-hidden', 'true');
        cacheProgressFill.style.width = '0%';
      } catch(e){}
    })();
  </script>
</body>
</html>

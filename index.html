<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>動画再生支援ツール</title>

  <!-- ====== Favicon / Icons (クロスプラットフォーム対応) ====== -->
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png" />
  <link rel="icon" type="image/png" sizes="48x48" href="favicon-48.png" />
  <link rel="shortcut icon" href="favicon.ico" />
  <link rel="manifest" href="site.webmanifest" />
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180.png" />
  <link rel="apple-touch-icon" sizes="167x167" href="apple-touch-icon-167.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120.png" />
  <link rel="apple-touch-icon" sizes="76x76" href="apple-touch-icon-76.png" />
  <link rel="mask-icon" href="safari-pinned-tab.svg" color="#0b74ff" />
  <link rel="icon" type="image/png" sizes="192x192" href="favicon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="favicon-512.png" />
  <meta name="msapplication-TileColor" content="#0b74ff" />
  <meta name="msapplication-TileImage" content="mstile-150x150.png" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-title" content="動画再生支援ツール" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="theme-color" content="#0b74ff" />
  <!-- ============================================================ -->

  <style>
    /* ---------------------------
       レスポンシブ制御（対象ボタン群のみ）
       --ctrl-size を画面幅に応じて clamp() で決定
       --------------------------- */
    :root{
      /* 最小 34px、推奨は viewport の比率、最大 72px */
      --ctrl-size: clamp(34px, 5.5vw, 72px);
      --ctrl-padding-x: calc(var(--ctrl-size) * 0.22);
      --ctrl-padding-y: calc(var(--ctrl-size) * 0.16);
      --ctrl-font: calc(var(--ctrl-size) * 0.28);
      --ctrl-radius: calc(var(--ctrl-size) * 0.18);

      /* 履歴内の小さめボタンはコントロールサイズを少し縮小して使う */
      --hist-scale: 0.78;
      --hist-size: calc(var(--ctrl-size) * var(--hist-scale));
      --hist-padding-x: calc(var(--hist-size) * 0.18);
      --hist-font: calc(var(--hist-size) * 0.28);
      --hist-radius: calc(var(--hist-size) * 0.16);

      /* タグチップのサイズ（履歴と連動） */
      --tag-font: calc(var(--hist-font) * 0.9);
      --tag-padding-y: 4px;
      --tag-padding-x: 8px;
      --tag-radius: 8px;
    }

    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans JP',Helvetica,Arial;overflow:hidden;background:#111}
    /* NOTE: pick ボタン を段落の下に置くため padding-top を通常に戻す */
    .center{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      padding:24px; /* 変更: 固定トップ領域分の大きな余白を戻す */
      box-sizing:border-box;
      gap:16px;
    }
    .btn{appearance:none;border:0;padding:10px 12px;border-radius:10px;box-shadow:0 1px 4px rgba(0,0,0,.12);cursor:pointer;background:#fff}
    .primary{background:#0b74ff;color:white}
    .muted{background:#f0f0f0;color:#111}

    /* 再読み込みボタンはページ内の右上に配置（ビューの外ではなくページの中に） */
    #reloadBtn {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 1200;

      /* もう少し小さめに調整（既存のコントロールサイズより少し小さく表示） */
      height: calc(var(--ctrl-size) * 0.60);
      min-width: calc(var(--ctrl-size) * 0.60);
      padding: 0 calc(var(--ctrl-padding-x) * 0.6);
      font-size: calc(var(--ctrl-font) * 0.80);
      border-radius: calc(var(--ctrl-radius) * 0.9);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
    }

    /* 変更: キャッシュクリアボタンを左端に配置 */
    #clearCacheBtn {
      position: absolute;
      top: 12px;
      left: 12px; /* ← 左端に移動 */
      z-index: 1200;
      height: calc(var(--ctrl-size) * 0.60);
      min-width: calc(var(--ctrl-size) * 0.60);
      padding: 0 calc(var(--ctrl-padding-x) * 0.6);
      font-size: calc(var(--ctrl-font) * 0.80);
      border-radius: calc(var(--ctrl-radius) * 0.9);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
    }

    /* キャッシュ削除時に表示するオーバーレイ（進捗） */
    .cache-overlay {
      position: fixed;
      left: 50%;
      top: 18px;
      transform: translateX(-50%);
      z-index: 1400;
      min-width: 320px;
      max-width: 94%;
      background: rgba(255,255,255,0.98);
      color: #111;
      border-radius: 10px;
      box-shadow: 0 8px 28px rgba(0,0,0,0.24);
      padding: 12px;
      display: none;
      align-items: center;
      gap: 12px;
      box-sizing: border-box;
      border: 1px solid #e6f0ff;
    }
    .cache-overlay[aria-hidden="false"] { display:flex; }

    .cache-overlay .status {
      flex: 1;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .cache-overlay .status .title { font-weight:700; font-size:14px; color:#08345f; }
    .cache-overlay .status .msg { font-size:13px; color:#425565; }

    .cache-overlay .progress-bg {
      width: 100%;
      height: 10px;
      background: #eef6ff;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    .cache-overlay .progress-fill {
      position: absolute;
      left: 0; top: 0; bottom: 0;
      width: 0%;
      background: linear-gradient(90deg,#43a2ff,#0b74ff);
      transition: width 220ms linear;
    }
    .cache-overlay .actions { display:flex; gap:8px; align-items:center; }
    .cache-overlay .actions .btn { height:34px; padding:6px 10px; min-width:80px; }

    /* ファイル選択画面：背景を白に、文字色を濃く（必要最小限の変更） */
    #pickerScreen{background:#fff;color:#111; position: relative;}
    #pickerScreen h1,#pickerScreen p{color:inherit}
    #pickerScreen .file-info{color:#444}

    /* ドラッグオーバー時の視覚的フィードバック（最小限） */
    #pickerScreen.dragover{
      outline: 3px dashed rgba(11,116,255,0.65);
      box-shadow: 0 6px 24px rgba(11,116,255,0.06);
    }

    /* 履歴リスト（最小限のスタイル） */
    .history-wrap{width:100%;max-width:880px;margin-top:0;/* fixed 化により余白不要 */margin-bottom:8px}
    .history-head{
      display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px;flex-wrap:wrap;
    }
    .history-left{display:flex;align-items:center;gap:8px}
    .history-controls{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .history-list{display:flex;flex-direction:column;gap:8px;max-height:calc(100vh - 320px);overflow:auto;padding:6px;border-radius:8px;background:#fafafa}
    /* ここは微修正：複数行タイトルに対応するため top 揃えにする */
    .history-item{display:flex;align-items:flex-start;gap:8px;padding:6px;border-radius:6px;background:transparent; border-bottom: 1px solid #e8e8e8;}
    .history-item:last-child{border-bottom: none;}
    .history-item:hover{background:#f5f5f5}
    .thumb{width:96px;height:54px;background:#ddd;border-radius:4px;flex:0 0 auto;display:flex;align-items:center;justify-content:center;overflow:hidden}
    .thumb img{width:100%;height:100%;object-fit:cover}
    .meta{flex:1;min-width:0}
    /* タイトル行をフレキシブルにしてチップと共存させる */
    .meta .title-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    /* ここを変更：タイトルを折り返して全文表示する */
    .meta .name{font-size:14px;color:#111;white-space:normal;overflow-wrap:break-word;word-break:break-word;overflow:visible;text-overflow:unset}
    .meta .sub{font-size:12px;color:#666;margin-top:2px}
    /* 新規：補足表示 */
    .meta .note{font-size:12px;color:#444;margin-top:6px;white-space:pre-wrap}
    /* タグチップ */
    .tag-chips{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .tag-chip{
      display:inline-flex;align-items:center;justify-content:center;
      padding:var(--tag-padding-y) var(--tag-padding-x);
      border-radius:var(--tag-radius);font-size:var(--tag-font);font-weight:600;
      color:#fff;white-space:nowrap;
      box-shadow: 0 1px 1px rgba(0,0,0,0.12);
      border: none;
      cursor: pointer;
    }
    .tag-chip.uncat{ background:#9aa0a6; color:#fff; }

    /* 履歴内アクションをグリッドにして2列表示（開く/削除 の1行目、名前編集/補足編集 の2行目） */
    .history-actions{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, auto));
      gap:6px;
      align-content:start;
      justify-items:start;
      margin-left:8px;
      /* 最小幅を確保して余白が潰れにくく */
      min-width: calc(var(--hist-size) * 2.6);
    }
    /* 小さいボタン（履歴用）をレスポンシブに */
    .small-btn{
      appearance:none;
      border:0;
      cursor:pointer;
      background:#fff;
      box-shadow:0 1px 3px rgba(0,0,0,0.12);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height: var(--hist-size);
      min-width: calc(var(--hist-size) * 1.2);
      padding: 0 var(--hist-padding-x);
      font-size: var(--hist-font);
      border-radius: var(--hist-radius);
      color:#111;
    }
    /* 名前入力・補足テキストエリアも高さを変える */
    .name-input{width:100%;font-size:calc(var(--hist-font) * 0.95);padding:6px;border-radius:6px;border:1px solid #ddd}
    .note-input{width:100%;font-size:calc(var(--hist-font) * 0.9);padding:6px;border-radius:6px;border:1px solid #ddd;min-height:56px;box-sizing:border-box}
    .edit-controls{display:flex;gap:6px;margin-left:6px}
    /* select にもレスポンシブサイズを適用 */
    select.sort-select{padding:0 calc(var(--hist-padding-x));border-radius:var(--hist-radius);border:1px solid #ddd;background:#fff;font-size:var(--hist-font);height:var(--hist-size);box-sizing:border-box}
    select.category-select{padding:0 calc(var(--hist-padding-x));border-radius:var(--hist-radius);border:1px solid #ddd;background:#fff;font-size:var(--hist-font);height:var(--hist-size);box-sizing:border-box}

    /* カテゴリ周りの小さな調整（追加） */
    .category-controls { display:flex; align-items:center; gap:8px; }

    /* カテゴリ編集モーダル */
    .modal-backdrop{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.4);display:none;align-items:center;justify-content:center;z-index:9999}
    .modal{background:#fff;border-radius:12px;padding:16px;max-width:720px;width:94%;max-height:80vh;overflow:auto;box-sizing:border-box}
    .modal h2{margin:0 0 12px;font-size:18px}
    .cat-row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
    .cat-row input[type="text"]{flex:1;padding:8px;border-radius:6px;border:1px solid #ddd}
    .cat-row input[type="color"]{width:44px;height:34px;border:1px solid #ddd;border-radius:6px;padding:2px;background:#fff}
    .modal .modal-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
    .reorder-btn{padding:6px 8px;border-radius:6px;border:1px solid #ddd;background:#fff;cursor:pointer}

    /* ビューア全体 */
    .viewer{display:none;height:100vh;width:100vw}
    .video-wrap{height:100vh;width:100vw;display:flex;align-items:center;justify-content:center;background:#000;position:relative;touch-action:none}
    video{max-width:100%;max-height:100vh;width:auto;height:auto;object-fit:contain;outline:none;touch-action:none;transition:transform .12s ease;}
    video.mirrored{transform:scaleX(-1);}

    /* 上部レイアウト：左（戻る+スキップ）、中央（シークバー）、右（再生トグル＋速度） */
    .top-control {
      position:absolute;
      top:8px;
      z-index:13;
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      background:rgba(0,0,0,0.12);
      border-radius:10px;
      backdrop-filter:blur(6px);
      box-sizing:border-box;
    }

    /* 左：戻る（固定左端） */
    #topBack {
      left:12px;
      top:8px;
    }

    /* まとめたスキップ群（戻るの直下に配置される、左寄せ） */
    .skip-group{
      position:absolute;
      left:12px;
      z-index:14;
      display:flex;
      flex-direction:column;
      gap:6px;
      transform:none;
      max-width: calc(100vw - 24px);
      box-sizing:border-box;
    }
    .skip-row{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
      max-width:100%;
    }
    .skip-row .skip-btn{
      appearance:none;border:0;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.95);box-shadow:0 1px 3px rgba(0,0,0,0.18);cursor:pointer;font-size:13px;
      flex:0 1 auto;
      min-width:0;
      white-space:nowrap;
      color:#111; /* 明示しておく（他ボタンと統一） */
    }

    /* 中央：シークバー（幅は JS で調整） */
    #topSeek {
      position:absolute;
      top:8px;
      z-index:12;
      left:auto;
      right:auto;
      padding:6px 12px;
      transform:none;
      transition: left .12s ease, right .12s ease;
      box-sizing:border-box;
      background:rgba(0,0,0,0.06);
      border-radius:10px;
    }

    /* シークバー入力自体 */
    .seek {
      -webkit-appearance: none;
      appearance: none;
      width:100%;
      height:4px;
      background:rgba(255,255,255,0.14);
      border-radius:4px;
      outline:none;
      cursor:pointer;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
      position:relative;
      z-index:1;
    }
    .seek::-webkit-slider-runnable-track{
      height:4px;border-radius:4px;
      background:linear-gradient(90deg, rgba(11,116,255,0.9) 0%, rgba(11,116,255,0.9) 0%, rgba(255,255,255,0.14) 0%);
    }
    .seek::-webkit-slider-thumb{
      -webkit-appearance:none;width:10px;height:10px;border-radius:50%;margin-top:-3px;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,0.4);
    }
    .seek::-webkit-slider-thumb{width:10px;height:10px;border-radius:50%}
    .seek::-moz-range-track{height:4px;border-radius:4px;background:rgba(255,255,255,0.14);}
    .seek::-moz-range-progress{background:rgba(11,116,255,0.9);height:4px;border-radius:4px;}
    .seek::-moz-range-thumb{width:10px;height:10px;border-radius:50%;background:#fff;border:0;box-shadow:0 1px 2px rgba(0,0,0,0.4);}

    /* マーカー表示レイヤー（シークバー上に重ねる） */
    .marker-layer {
      position:absolute;
      left:6px; right:6px;
      top:6px;
      bottom:6px;
      pointer-events:none;
      z-index:2;
    }
    .marker {
      position:absolute;
      width:2px;
      height:12px;
      border-radius:2px;
      background:#ffdd00;
      box-shadow:0 0 6px rgba(255,220,0,0.6);
      pointer-events:none;
      transform: none;
    }
    .marker[aria-label]{cursor:default}

    /* 右：再生トグル（固定右端） */
    #topToggle { right:12px; top:8px; position:absolute; z-index:13; }

    .top-btn{
      padding:6px 10px;border-radius:8px;font-size:13px;background:rgba(255,255,255,0.95);
      box-shadow:0 1px 3px rgba(0,0,0,0.18);cursor:pointer;
      color:#111; /* 他ボタンと合わせる */
    }
    .top-btn[disabled]{opacity:0.5;cursor:default}

    /* ここを変更：停止（aria-pressed=true）の見た目を他のボタンと同じにする */
    #playToggleBtn[aria-pressed="true"]{
      background: rgba(255,255,255,0.95);
      color: #111;
    }

    /* 速度操作は再生の下に表示（右端寄せ） */
    .overlay-right{
      position:absolute;
      right:12px;
      /* 再生ボタンの高さ（--ctrl-size）を考慮して下にずらす（重ならないように） */
      top: calc(8px + var(--ctrl-size) + 8px);
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:6px;
      border-radius:10px;
      background:rgba(0,0,0,0.24);
      backdrop-filter:blur(6px);
      z-index:11;
      align-items:center;
    }
    .overlay-right .btn{padding:8px 10px;border-radius:8px;font-size:14px}
    .speed-display{min-width:64px;text-align:center;color:#fff;font-weight:600}

    /* マーカー操作ボタン（追加） */
    .marker-controls{display:flex;gap:6px;align-items:center}
    .marker-controls .marker-btn{padding:6px 10px;border-radius:8px;font-size:14px;background:rgba(255,255,255,0.95);cursor:pointer}

    /* ======================================================
       ここから：ボタン群のサイズだけをレスポンシブに変更
       — レイアウト（配置）は変えない（position等はそのまま）
       ====================================================== */
    .top-btn,
    .skip-btn,
    .marker-btn,
    .overlay-right .btn {
      height: var(--ctrl-size);
      min-width: var(--ctrl-size);
      padding: 0 var(--ctrl-padding-x);
      font-size: var(--ctrl-font);
      border-radius: var(--ctrl-radius);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
    }

    .top-btn { padding-top: calc(var(--ctrl-padding-y)); padding-bottom: calc(var(--ctrl-padding_y)); }
    .skip-btn { padding-top: calc(var(--ctrl-padding-y) * 0.9); padding-bottom: calc(var(--ctrl-padding_y) * 0.9); }
    .marker-btn { padding-top: calc(var(--ctrl-padding-y) * 0.9); padding-bottom: calc(var(--ctrl-padding_y) * 0.9); }

    /* 検索バー用（history search） */
    .history-search{display:flex;gap:8px;align-items:center;margin:8px 0 8px}
    .history-search input[type="search"]{
      flex:1;padding:8px;border-radius:8px;border:1px solid #ddd;font-size:14px;background:#fff;
    }
    .history-search .clear-btn{padding:8px 10px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer}

    @media (max-width:480px){
      .overlay-right{ top: calc(8px + var(--ctrl-size) + 6px); }
      .seek::-webkit-slider-thumb{width:14px;height:14px;margin-top:-5px}
      .seek{height:6px}
      #topSeek{left:12px; right:12px}
      .history-controls{gap:6px}
    }

    /* =======================
       アップロード進捗 UI 用の最小スタイル
       ======================= */
    .upload-progress-container{
      width:100%;
      max-width:880px;
      margin-top:12px;
      background: #fff;
      border-radius:12px;
      padding:12px;
      box-shadow: 0 6px 18px rgba(11,116,255,0.04);
      border: 1px solid #eef4ff;
      box-sizing:border-box;
    }
    .upload-progress-list{display:flex;flex-direction:column;gap:10px;max-height:260px;overflow:auto;padding-right:6px}
    .progress-item{
      display:flex;
      align-items:center;
      gap:10px;
      background: #f8fbff;
      padding:8px;
      border-radius:8px;
      box-shadow: inset 0 0 0 1px rgba(11,116,255,0.03);
    }
    .index-badge{
      width:34px;height:34px;border-radius:8px;background: rgba(11,116,255,0.12);
      display:inline-flex;align-items:center;justify-content:center;font-weight:700;color:#0b74ff;flex:0 0 auto;
      font-size:14px;
    }
    .progress-main{flex:1;min-width:0;display:flex;flex-direction:column;gap:6px}
    .progress-title{font-size:13px;color:#0d2540;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .progress-row{display:flex;align-items:center;gap:8px}
    .progress-bar-bg{flex:1;background:#eaf2ff;border-radius:10px;height:12px;overflow:hidden;position:relative}
    .progress-bar-fill{position:absolute;left:0;top:0;bottom:0;width:0;background:linear-gradient(90deg,#43a2ff,#0b74ff);border-radius:10px;transition:width 240ms linear}
    .progress-meta{display:flex;flex-direction:column;align-items:flex-end;gap:4px;flex:0 0 110px}
    .progress-percent{font-size:13px;color:#08345f;font-weight:700}
    .progress-size{font-size:12px;color:#556b7b}
    /* 完了表示 */
    .progress-item.done{background:#f3fbf7}
    .progress-item.done .index-badge{background:rgba(34,197,94,0.10);color:#22c55e}
    .progress-item.error{background:#fff6f6}
    .progress-item.error .index-badge{background:rgba(220,38,38,0.08);color:#dc2626}

    /* 進捗項目用キャンセルボタンの調整 */
    .progress-cancel-btn{
      margin-left:8px;
      flex:0 0 auto;
      height:34px;
      min-width:72px;
      padding:6px 8px;
      font-size:13px;
    }

    .progress-item.cancelled{opacity:0.6}
  </style>
</head>
<body>

  <!-- ファイル取得画面 -->
  <main id="pickerScreen" class="center" aria-live="polite">
    <!-- 再読み込みボタンをページ内の左上に配置 -->
    <button id="reloadBtn" class="btn muted" type="button" title="ページを再読み込みします" aria-label="ページを再読み込み">再読み込み</button>
    <!-- 追加: キャッシュ削除ボタン（左端に移動済み） -->
    <button id="clearCacheBtn" class="btn muted" type="button" title="アプリ内キャッシュを削除します" aria-label="アプリ内キャッシュを削除">キャッシュ削除</button>

    <!-- キャッシュ削除時の進捗オーバーレイ -->
    <div id="cacheOverlay" class="cache-overlay" aria-hidden="true">
      <div class="status">
        <div class="title" id="cacheOverlayTitle">キャッシュを削除しています…</div>
        <div class="msg" id="cacheOverlayMsg">準備中</div>
        <div class="progress-bg" aria-hidden="true">
          <div id="cacheProgressFill" class="progress-fill" style="width:0%"></div>
        </div>
      </div>
      <div class="actions">
        <button id="cacheCancelBtn" class="btn muted" type="button">キャンセル</button>
        <button id="cacheCloseBtn" class="btn muted" type="button" style="display:none">閉じる</button>
      </div>
    </div>

    <div style="text-align:center;width:100%;max-width:880px">
      <h1 style="margin:0 0 8px">動画ファイルを選択</h1>
      <p style="margin:0 0 16px;color:#bbb">「ファイルを取得」を押して端末から動画を選んでください</p>

      <!-- 要望に合わせてボタンを段落の直下に配置 -->
      <div style="margin-top:8px">
        <button id="pickBtn" class="btn primary" type="button" aria-label="ファイルを取得">ファイルを取得</button>
        <!-- multiple を追加して複数選択をサポート -->
        <input id="fileInput" type="file" accept="video/*" multiple style="display:none" />
      </div>
    </div>

    <div class="file-info" id="fileName" style="color:#444">まだファイルが選択されていません</div>

    <!-- 追加: アップロード進捗表示領域 -->
    <div id="uploadProgress" class="upload-progress-container" style="display:none" aria-live="polite">
      <div id="uploadProgressList" class="upload-progress-list" role="list"></div>
    </div>

    <div class="history-wrap" id="historyWrap">
      <div class="history-head">
        <!-- 左側: コントロール群を順序どおりに配置 -->
        <div class="history-left">
          <div class="history-controls" role="group" aria-label="履歴コントロール">
            <!-- 追加順（sortBy） -->
            <select id="sortBy" class="sort-select" aria-label="並び替え基準">
              <option value="created">追加順</option>
              <option value="name">名前順</option>
            </select>

            <!-- 降順/昇順（sortOrder） -->
            <select id="sortOrder" class="sort-select" aria-label="昇順降順">
              <option value="desc">降順</option>
              <option value="asc">昇順</option>
            </select>

            <!-- 全て（categorySelect） -->
            <select id="categorySelect" class="category-select" aria-label="表示する項目">
              <!-- option は JS で埋める -->
            </select>

            <!-- 項目編集（モーダルを開く） -->
            <button id="editCategoryBtn" class="small-btn" title="項目の名前・色を編集">項目編集</button>

            <!--
              ※ ユーザー要望：モーダル内で追加/削除を行うため、
                 外側の「新規項目」「項目削除」ボタンは削除しました。
            -->
          </div>
        </div>

        <!-- 右側: 履歴件数表示 + 履歴を消去 -->
        <div style="display:flex;align-items:center;gap:8px">
          <div id="historyCount" aria-live="polite" style="color:#666">0 / 0 件表示</div>
          <button id="clearHistoryBtn" class="small-btn">履歴を消去</button>
        </div>
      </div>

      <!-- 検索バー：名前順、昇順、全て、項目編集などの行の下に配置 -->
      <div class="history-search" aria-label="履歴検索">
        <input id="historySearch" type="search" placeholder="履歴を検索" aria-label="履歴のタイトルを検索" />
        <button id="clearSearchBtn" class="clear-btn" title="検索をクリア">クリア</button>
      </div>

      <div class="history-list" id="historyList" aria-live="polite"></div>
    </div>
  </main>

  <!-- カテゴリ編集モーダル -->
  <div id="modalBackdrop" class="modal-backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="項目編集">
      <h2>項目編集（上/下ボタンで並び替え）</h2>
      <div id="categoryEditorContent">
        <!-- JS がここにカテゴリ行を描画します -->
      </div>
      <div class="modal-actions">
        <!-- 新設: モーダル内で項目を追加できるボタン -->
        <button id="addCategoryInModal" class="small-btn" title="新しい項目を追加">追加</button>
        <button id="closeCategoryEditor" class="small-btn">閉じる</button>
      </div>
    </div>
  </div>

  <!-- ビューア画面 -->
  <section id="viewer" class="viewer" aria-hidden="true">
    <div class="video-wrap" id="videoWrap">
      <video id="video" playsinline webkit-playsinline preload="metadata" tabindex="-1" controlslist="nodownload"></video>

      <!-- 左上：戻るボタン -->
      <div id="topBack" class="top-control" role="group" aria-label="戻るボタン">
        <button id="backBtn" class="top-btn" aria-label="最初の画面に戻る">戻る</button>
      </div>

      <!-- 左上：まとめたスキップ群（戻るの下、常に左寄せ） -->
      <div id="skipGroup" class="skip-group" aria-hidden="false">
        <!-- 3秒グループ: 「3秒戻る 3秒進む」 -->
        <div class="skip-row" aria-label="3秒スキップ">
          <button id="back3Btn" class="skip-btn" aria-label="3秒戻る">« 3s</button>
          <button id="fwd3Btn" class="skip-btn" aria-label="3秒進む">3s »</button>
        </div>
        <!-- 5秒グループ -->
        <div class="skip-row" aria-label="5秒スキップ">
          <button id="back5Btn" class="skip-btn" aria-label="5秒戻る">« 5s</button>
          <button id="fwd5Btn" class="skip-btn" aria-label="5秒進む">5s »</button>
        </div>

        <!-- ミラー -->
        <div class="skip-row" aria-label="ミラー操作">
          <button id="mirrorBtn" class="skip-btn" aria-pressed="false" aria-label="左右反転（ミラー）">ミラー</button>
        </div>
      </div>

      <!-- 中央：シークバー（位置は JS で中央寄せになるよう調整） -->
      <div id="topSeek" class="top-control" role="group" aria-label="再生バー">
        <input id="seekBar" class="seek" type="range" min="0" max="100" step="0.1" value="0" aria-label="再生位置" />
        <div id="markerLayer" class="marker-layer" aria-hidden="true"></div>
      </div>

      <!-- 右上：再生/一時停止 -->
      <div id="topToggle" class="top-control" role="group" aria-label="再生操作">
        <button id="playToggleBtn" class="top-btn" aria-pressed="false" aria-label="再生">再生</button>
      </div>

      <!-- 右上：速度操作（再生ボタンの下） -->
      <div class="overlay-right" id="overlayRight" aria-hidden="false">
        <div style="display:flex;gap:8px;align-items:center">
          <button id="speedMinus" class="btn" aria-label="速度を下げる">−</button>
          <div id="speedDisplay" class="speed-display">1.00x</div>
          <button id="speedPlus" class="btn" aria-label="速度を上げる">＋</button>
        </div>

        <div class="marker-controls" role="group" aria-label="マーカー操作">
          <button id="markerJump" class="marker-btn" aria-label="マーカーへジャンプ">&gt;</button>
          <button id="markerAdd" class="marker-btn" aria-label="マーカーを追加">+</button>
          <button id="markerRemove" class="marker-btn" aria-label="マーカーを削除">-</button>
        </div>
      </div>
    </div>
  </section>

  <script>
    const fileInput = document.getElementById('fileInput');
    const fileNameEl = document.getElementById('fileName');
    const pickBtn = document.getElementById('pickBtn');
    const reloadBtn = document.getElementById('reloadBtn');
    const clearCacheBtn = document.getElementById('clearCacheBtn');

    const cacheOverlay = document.getElementById('cacheOverlay');
    const cacheOverlayTitle = document.getElementById('cacheOverlayTitle');
    const cacheOverlayMsg = document.getElementById('cacheOverlayMsg');
    const cacheProgressFill = document.getElementById('cacheProgressFill');
    const cacheCancelBtn = document.getElementById('cacheCancelBtn');
    const cacheCloseBtn = document.getElementById('cacheCloseBtn');

    const pickerScreen = document.getElementById('pickerScreen');
    const viewer = document.getElementById('viewer');
    const video = document.getElementById('video');
    const videoWrap = document.getElementById('videoWrap');

    const playToggleBtn = document.getElementById('playToggleBtn');
    const speedMinus = document.getElementById('speedMinus');
    const speedPlus = document.getElementById('speedPlus');
    const speedDisplay = document.getElementById('speedDisplay');

    const backBtn = document.getElementById('backBtn');

    const back3Btn = document.getElementById('back3Btn');
    const back5Btn = document.getElementById('back5Btn');
    const fwd3Btn = document.getElementById('fwd3Btn');
    const fwd5Btn = document.getElementById('fwd5Btn');

    const mirrorBtn = document.getElementById('mirrorBtn');

    const skipGroup = document.getElementById('skipGroup');

    const historyList = document.getElementById('historyList');
    const clearHistoryBtn = document.getElementById('clearHistoryBtn');
    const sortBySelect = document.getElementById('sortBy');
    const sortOrderSelect = document.getElementById('sortOrder');

    const seekBar = document.getElementById('seekBar');
    const topBack = document.getElementById('topBack');
    const topSeek = document.getElementById('topSeek');
    const topToggle = document.getElementById('topToggle');
    const overlayRight = document.getElementById('overlayRight');

    const markerAddBtn = document.getElementById('markerAdd');
    const markerJumpBtn = document.getElementById('markerJump');
    const markerRemoveBtn = document.getElementById('markerRemove');
    const markerLayer = document.getElementById('markerLayer');

    const categorySelect = document.getElementById('categorySelect');
    const editCategoryBtn = document.getElementById('editCategoryBtn');
    const addCategoryInModal = document.getElementById('addCategoryInModal');
    const modalBackdrop = document.getElementById('modalBackdrop');
    const categoryEditorContent = document.getElementById('categoryEditorContent');
    const closeCategoryEditor = document.getElementById('closeCategoryEditor');

    const historyCountEl = document.getElementById('historyCount');

    // upload progress elements
    const uploadProgressContainer = document.getElementById('uploadProgress');
    const uploadProgressList = document.getElementById('uploadProgressList');

    // search elements
    const historySearch = document.getElementById('historySearch');
    const clearSearchBtn = document.getElementById('clearSearchBtn');

    let currentObjectUrl = null;
    let currentHistoryId = null;
    const MAX_HISTORY = 1000;

    const SPEED_STEP = 0.05;
    const SPEED_MIN = 0.05;
    const SPEED_MAX = 4.0;
    let isSeeking = false;

    let markers = [];

    // upload controllers map: key -> controller object { aborted: boolean }
    const uploadControllers = new Map();

    // モーダル用の一時カテゴリ配列（編集中に並び替え・追加・削除を行うため）
    let modalUsers = null;

    const SORT_KEY = 'videoHistorySort';
    function loadSortSettings(){
      try{
        const raw = localStorage.getItem(SORT_KEY);
        if (!raw) return {by:'created', order:'desc'};
        return JSON.parse(raw);
      }catch(e){ return {by:'created', order:'desc'}; }
    }
    function saveSortSettings(s){ localStorage.setItem(SORT_KEY, JSON.stringify(s)); }
    let sortSettings = loadSortSettings();
    sortBySelect.value = sortSettings.by;
    sortOrderSelect.value = sortSettings.order;

    const DB_NAME = 'videoHistory';
    const STORE_NAME = 'videos';
    let dbPromise = null;

    function openDB(){
      if (dbPromise) return dbPromise;
      dbPromise = new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)){
            const store = db.createObjectStore(STORE_NAME, {keyPath:'id', autoIncrement:true});
            // keep simple indexes to avoid edge issues
            try {
              store.createIndex('byCreated', 'createdAt');
            } catch (e) {
              // ignore if index creation fails on older browsers
            }
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
      return dbPromise;
    }

    // IndexedDB のリクエストを Promise 化
    function promisifyRequest(req){
      return new Promise((resolve, reject) => {
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    // トランザクション完了を待つ（oncomplete / onerror / onabort を監視）
    function waitForTransactionComplete(tx){
      return new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onabort = () => reject(new Error('Transaction aborted'));
        tx.onerror = () => reject(tx.error || new Error('Transaction error'));
      });
    }

    async function getAllFromStore(store){
      return new Promise((resolve, reject) => {
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function getHistory(){
      const db = await openDB();
      const tx = db.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);
      const all = await getAllFromStore(store);
      // wait transaction complete for best practice (readonly usually completes quickly)
      try { await waitForTransactionComplete(tx); } catch (e){ /* ignore */ }
      return all;
    }

    async function getEntry(id){
      const db = await openDB();
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(STORE_NAME,'readonly');
        const store = tx.objectStore(STORE_NAME);
        const req = store.get(Number(id));
        req.onsuccess = ()=> {
          resolve(req.result);
        };
        req.onerror = ()=>reject(req.error);
      });
    }

    // ---------- 修正済み: deleteEntry (blob を確実に解放する手順を追加) ----------
    async function deleteEntry(id){
      const db = await openDB();
      return new Promise(async (resolve, reject) => {
        try {
          // revoke object URL if currently viewing this entry
          if (currentHistoryId != null && Number(currentHistoryId) === Number(id)) {
            try {
              if (currentObjectUrl) {
                URL.revokeObjectURL(currentObjectUrl);
                currentObjectUrl = null;
              }
              video.pause();
              video.removeAttribute('src');
              video.load();
            } catch (e) { /* ignore */ }
            currentHistoryId = null;
          }

          const tx = db.transaction(STORE_NAME,'readwrite');
          const store = tx.objectStore(STORE_NAME);

          // first try to get, null out blob to help free space, then delete
          const getReq = store.get(Number(id));
          getReq.onsuccess = async () => {
            try {
              const val = getReq.result;
              if (val && val.blob) {
                // clear blob reference to help browser free space
                val.blob = null;
                const putReq = store.put(val);
                await promisifyRequest(putReq);
                // wait a tick for tx ordering
              }
            } catch (e) {
              console.warn('blob clear failed', e);
            } finally {
              const delReq = store.delete(Number(id));
              delReq.onsuccess = ()=> {
                waitForTransactionComplete(tx).then(resolve).catch(reject);
              };
              delReq.onerror = ()=> reject(delReq.error);
            }
          };
          getReq.onerror = () => {
            // fallback: just delete
            const delReq2 = store.delete(Number(id));
            delReq2.onsuccess = ()=> {
              waitForTransactionComplete(tx).then(resolve).catch(reject);
            };
            delReq2.onerror = ()=> reject(delReq2.error);
          };
        } catch (err) {
          reject(err);
        }
      });
    }

    // ---------- 修正済み: clearHistory（データベース丸ごと削除） ----------
    async function clearHistory(){
      try{
        // revoke any currently created objectURL
        try {
          if (currentObjectUrl) {
            try { URL.revokeObjectURL(currentObjectUrl); } catch(e){}
            currentObjectUrl = null;
          }
          video.pause();
          video.removeAttribute('src');
          video.load();
          currentHistoryId = null;
        } catch (e){}

        // abort pending uploads
        try {
          for (const ctrl of uploadControllers.values()) {
            try { ctrl.aborted = true; } catch(e){}
          }
        } catch(e){}

        // delete entire IndexedDB database to ensure blobs are removed
        await new Promise((resolve, reject) => {
          try {
            const delReq = indexedDB.deleteDatabase(DB_NAME);
            delReq.onsuccess = () => resolve();
            delReq.onerror = () => reject(delReq.error);
            delReq.onblocked = () => {
              console.warn('deleteDatabase blocked');
              resolve();
            };
          } catch (err) {
            reject(err);
          }
        });

        // reset our cached dbPromise so openDB will recreate it
        dbPromise = null;
        await openDB();

        // also try clearing Cache Storage (if any service worker caches exist)
        if ('caches' in window) {
          try {
            const keys = await caches.keys();
            await Promise.all(keys.map(k => caches.delete(k)));
          } catch (e) { console.warn('Cache Storage clear failed', e); }
        }

        // refresh UI
        populateCategorySelect();
        renderHistory();
      } catch (err){
        console.warn('clearHistory error', err);
        throw err;
      }
    }

    async function trimHistoryLimit(db){
      try{
        const tx = db.transaction(STORE_NAME,'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const all = await getAllFromStore(store);
        const sorted = all.sort((a,b)=>b.createdAt - a.createdAt);
        if (sorted.length <= MAX_HISTORY) {
          try { await waitForTransactionComplete(tx); } catch(e){}
          return;
        }
        const toRemove = sorted.slice(MAX_HISTORY);
        for (const item of toRemove) store.delete(item.id);
        await waitForTransactionComplete(tx);
      }catch(e){console.warn(e)}
    }

    async function updateEntryName(id, newName){
      const db = await openDB();
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(STORE_NAME,'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const req = store.get(Number(id));
        req.onsuccess = ()=>{
          const val = req.result;
          if (!val) {
            waitForTransactionComplete(tx).then(()=>resolve(false)).catch(()=>resolve(false));
            return;
          }
          val.name = newName;
          const put = store.put(val);
          put.onsuccess = ()=> {
            waitForTransactionComplete(tx).then(()=>resolve(true)).catch(reject);
          };
          put.onerror = ()=>reject(put.error);
        };
        req.onerror = ()=>reject(req.error);
      });
    }

    // 新規: 補足（note）更新関数
    async function updateEntryNote(id, newNote){
      const db = await openDB();
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(STORE_NAME,'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const req = store.get(Number(id));
        req.onsuccess = ()=>{
          const val = req.result;
          if (!val) {
            waitForTransactionComplete(tx).then(()=>resolve(false)).catch(()=>resolve(false));
            return;
          }
          val.note = newNote;
          const put = store.put(val);
          put.onsuccess = ()=> {
            waitForTransactionComplete(tx).then(()=>resolve(true)).catch(reject);
          };
          put.onerror = ()=>reject(put.error);
        };
        req.onerror = ()=>reject(req.error);
      });
    }

    // --- 新規追加: マーカー保存関連 ---
    function markersEqual(a,b){
      if (!Array.isArray(a)) a = [];
      if (!Array.isArray(b)) b = [];
      if (a.length !== b.length) return false;
      for (let i=0;i<a.length;i++){
        if (!isFinite(a[i]) || !isFinite(b[i])) return false;
        if (Math.abs(a[i] - b[i]) > 1e-6) return false;
      }
      return true;
    }

    async function updateEntryMarkers(id, newMarkers){
      const db = await openDB();
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(STORE_NAME,'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const req = store.get(Number(id));
        req.onsuccess = async ()=>{
          const val = req.result;
          if (!val) {
            try { await waitForTransactionComplete(tx); } catch(e){}
            resolve(false);
            return;
          }
          const current = Array.isArray(val.markers) ? val.markers : (Array.isArray(val.markerTimes) ? val.markerTimes : []);
          if (markersEqual(current, newMarkers)) {
            // 変更なし -> no-op
            try { await waitForTransactionComplete(tx); } catch(e){}
            resolve(true);
            return;
          }
          val.markers = Array.isArray(newMarkers) ? newMarkers.slice() : [];
          // cleanup legacy keys optionally
          if (val.hasOwnProperty('markerTimes')) delete val.markerTimes;
          const putReq = store.put(val);
          putReq.onsuccess = ()=> {
            waitForTransactionComplete(tx).then(()=>resolve(true)).catch(reject);
          };
          putReq.onerror = ()=>reject(putReq.error);
        };
        req.onerror = ()=>reject(req.error);
      });
    }

    // --- end マーカー保存関連 ---

    // --- 新規: カテゴリ関連 ---
    const CATS_KEY = 'videoHistoryCategories';
    // 内部固定ID: 未分類（削除不可）と全て（表示用）
    const UNCATEGORIZED_ID = 'uncategorized';
    const ALL_ID = 'all';

    // カラー関連ユーティリティ
    function isValidHexColor(s){
      return /^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(s);
    }
    function expandHex(hex){
      if (!hex) return hex;
      if (hex.length === 4) {
        return '#' + hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];
      }
      return hex;
    }
    function hashStringToColor(str){
      // simple deterministic color from string (fallback)
      let h = 2166136261 >>> 0;
      for (let i=0;i<str.length;i++){
        h = Math.imul(h ^ str.charCodeAt(i), 16777619) >>> 0;
      }
      const r = (h & 0xff0000) >> 16;
      const g = (h & 0x00ff00) >> 8;
      const b = (h & 0x000ff);
      const mix = 90;
      const rr = Math.round((r + mix) / 2);
      const gg = Math.round((g + mix) / 2);
      const bb = Math.round((b + mix) / 2);
      return '#' + [rr,gg,bb].map(x => x.toString(16).padStart(2,'0')).join('');
    }
    function hexToRgb(hex){
      if(!hex) return null;
      hex = expandHex(hex);
      const m = /^#?([0-9a-fA-F]{6})$/.exec(hex);
      if (!m) return null;
      const v = m[1];
      return { r: parseInt(v.slice(0,2),16), g: parseInt(v.slice(2,4),16), b: parseInt(v.slice(4,6),16) };
    }
    function isLightColor(hex){
      const rgb = hexToRgb(hex);
      if (!rgb) return false;
      const L = 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;
      return L > 180;
    }
    function contrastingTextColor(hex){
      return isLightColor(hex) ? '#111' : '#fff';
    }

    function loadUserCategories(){
      try {
        const raw = localStorage.getItem(CATS_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        // ensure color exists; default to white per request
        let changed = false;
        for (const c of arr){
          if (!c.color) { c.color = '#ffffff'; changed = true; }
        }
        if (changed) saveUserCategories(arr);
        return arr;
      } catch (e) { return []; }
    }
    function saveUserCategories(arr){
      try { localStorage.setItem(CATS_KEY, JSON.stringify(arr)); } catch(e){ console.warn('カテゴリ保存失敗', e); }
    }

    // ヘルパー: モーダル編集中の配列を保存して UI を更新するユーティリティ
    function saveModalUsersAndRefresh(){
      try {
        if (Array.isArray(modalUsers)) {
          saveUserCategories(modalUsers);
        }
      } catch (e) {
        console.warn('modal save failed', e);
      }
      try { populateCategorySelect(); } catch(e){}
      try { renderHistory(); } catch(e){}
    }

    // カテゴリリストを UI に反映（"全て" / "未分類" / ユーザ作成分）
    function populateCategorySelect(){
      const users = loadUserCategories();
      // preserve selection
      const prev = categorySelect.value;
      categorySelect.innerHTML = '';
      const optAll = document.createElement('option'); optAll.value = ALL_ID; optAll.textContent = '全て';
      const optUn = document.createElement('option'); optUn.value = UNCATEGORIZED_ID; optUn.textContent = '未分類';
      categorySelect.appendChild(optAll);
      categorySelect.appendChild(optUn);
      for (const c of users){
        const o = document.createElement('option');
        o.value = c.id;
        o.textContent = c.name;
        categorySelect.appendChild(o);
      }
      // restore if possible
      if (prev) {
        const found = Array.from(categorySelect.options).some(o=>o.value===prev);
        categorySelect.value = found ? prev : ALL_ID;
      } else {
        categorySelect.value = ALL_ID;
      }
    }

    // カテゴリ作成（ユニークIDを生成）。色指定も受け付ける（prompt）
    function createCategory(name){
      const users = loadUserCategories();
      const id = 'cat_' + Date.now() + '_' + Math.floor(Math.random()*1000);
      const nm = name || ('項目 ' + (users.length + 1));
      // ask for color
      let color = prompt('項目のカラーを入力してください（例: #ff6633）。何も入力しなければデフォルトの白になります。', '');
      if (color) {
        color = color.trim();
        if (!color.startsWith('#')) color = '#' + color;
        color = color.toLowerCase();
        if (!isValidHexColor(color)) {
          alert('無効なカラー指定です。白 (#ffffff) を割り当てます。');
          color = '#ffffff';
        } else {
          color = expandHex(color);
        }
      } else {
        color = '#ffffff';
      }
      users.push({id, name: nm, createdAt: Date.now(), color});
      saveUserCategories(users);
      populateCategorySelect();
      return id;
    }

    // カテゴリ削除（ユーザが選択しているカテゴリのみ。未分類 / 全て は不可）
    async function deleteCategory(id){
      if (!id) return;
      if (id === UNCATEGORIZED_ID || id === ALL_ID) return;
      if (!confirm('選択中の項目を削除しますか？ 削除するとその項目に属していたファイルは「未分類」に戻ります。')) return;
      // remove from saved list
      let users = loadUserCategories();
      users = users.filter(c=>c.id !== id);
      saveUserCategories(users);
      // reassign entries in DB that had this category -> remove it; if no categories left, remain uncategorized (empty array)
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME,'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const all = await getAllFromStore(store);
        for (const it of all){
          const cids = Array.isArray(it.categoryIds) ? it.categoryIds.slice() : (it.categoryId ? [it.categoryId] : []);
          if (cids.includes(id)){
            const newCids = cids.filter(x=>x !== id);
            it.categoryIds = newCids;
            if (it.hasOwnProperty('categoryId')) delete it.categoryId;
            store.put(it);
          }
        }
        await waitForTransactionComplete(tx);
      } catch (e) { console.warn('カテゴリ削除時の再割当でエラー', e); }
      populateCategorySelect();
      categorySelect.value = ALL_ID;
      renderHistory();
    }

    // カテゴリの並び替え（上へ/下へ）
    function moveCategoryUp(id){
      const users = loadUserCategories();
      const i = users.findIndex(u=>u.id===id);
      if (i > 0){
        const tmp = users[i-1];
        users[i-1] = users[i];
        users[i] = tmp;
        saveUserCategories(users);
      }
    }
    function moveCategoryDown(id){
      const users = loadUserCategories();
      const i = users.findIndex(u=>u.id===id);
      if (i >= 0 && i < users.length - 1){
        const tmp = users[i+1];
        users[i+1] = users[i];
        users[i] = tmp;
      }
    }

    // ヘルパー: 配列の等価比較（順序無視）
    function arraysEqualAsSets(a,b){
      if (!Array.isArray(a)) a = [];
      if (!Array.isArray(b)) b = [];
      if (a.length !== b.length) return false;
      const sa = a.slice().sort();
      const sb = b.slice().sort();
      for (let i=0;i<sa.length;i++){ if (sa[i] !== sb[i]) return false; }
      return true;
    }

    // エントリのカテゴリを更新（newCategoryId: string | string[]）
    // 改善: 同じ内容なら書き込みを行わないガード + 簡易リトライを導入
    async function updateEntryCategory(id, newCategoryId){
      const db = await openDB();
      const normalized = Array.isArray(newCategoryId) ? newCategoryId.slice() : (newCategoryId ? [newCategoryId] : []);
      // normalize: remove ALL_ID and UNCATEGORIZED_ID from actual assigned list; UNCATEGORIZED == []

      const filteredNorm = normalized.filter(x => x && x !== ALL_ID && x !== UNCATEGORIZED_ID);

      // read current entry first to avoid unnecessary writes
      try {
        const txr = db.transaction(STORE_NAME, 'readonly');
        const storer = txr.objectStore(STORE_NAME);
        const cur = await new Promise((resolve, reject) => {
          const rq = storer.get(Number(id));
          rq.onsuccess = () => resolve(rq.result);
          rq.onerror = () => reject(rq.error);
        });
        try { await waitForTransactionComplete(txr); } catch(e){}
        const currentCids = Array.isArray(cur && cur.categoryIds) ? cur.categoryIds : (cur && cur.categoryId ? [cur.categoryId] : []);
        if (arraysEqualAsSets(currentCids, filteredNorm)) {
          // 既に同じ割当て -> no-op
          return true;
        }
      } catch (e) {
        // 読み込み失敗しても後続で書き込みを試みる
        console.warn('updateEntryCategory: 現在値読み込み失敗、書き込みを試みます', e);
      }

      // try to write, with 3 attempts in case of transient tx error
      let attempts = 0;
      while (attempts < 3) {
        attempts++;
        try {
          const tx = db.transaction(STORE_NAME,'readwrite');
          const store = tx.objectStore(STORE_NAME);
          const req = store.get(Number(id));
          const val = await new Promise((resolve, reject) => {
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });
          if (!val) {
            try { await waitForTransactionComplete(tx); } catch(e){}
            return false;
          }
          val.categoryIds = filteredNorm.slice(); // assign array (空配列 = 未分類)
          if (val.hasOwnProperty('categoryId')) delete val.categoryId;
          const putReq = store.put(val);
          await promisifyRequest(putReq);
          await waitForTransactionComplete(tx);
          return true;
        } catch (err) {
          console.warn('updateEntryCategory attempt', attempts, 'failed', err);
          // transient errors: retry after small delay
          if (attempts < 3) {
            await new Promise(r => setTimeout(r, 80 + Math.random()*50));
            continue;
          } else {
            throw err;
          }
        }
      }
    }

    // シンプルなキュー: 同一エントリに対する更新を直列化する（項目移動の競合防止）
    const updateQueue = new Map();
    function enqueueUpdateEntryCategory(id, newCategoryArr){
      const key = String(id);
      const doUpdate = () => updateEntryCategory(id, newCategoryArr);
      if (updateQueue.has(key)) {
        // chain after existing promise
        const p = updateQueue.get(key).then(() => doUpdate());
        // store chained promise and ensure cleanup
        updateQueue.set(key, p.then(()=>{ updateQueue.delete(key); return; }).catch((e)=>{ updateQueue.delete(key); throw e; }));
        return p;
      } else {
        const p = doUpdate();
        updateQueue.set(key, p.then(()=>{ updateQueue.delete(key); return; }).catch((e)=>{ updateQueue.delete(key); throw e; }));
        return p;
      }
    }

    function formatBytes(n){ if (n<1024) return n + ' B'; if (n<1024*1024) return Math.round(n/1024) + ' KB'; return (n/(1024*1024)).toFixed(2) + ' MB'; }

    function sortItems(items){
      const by = sortSettings.by || 'created';
      const order = (sortSettings.order === 'asc') ? 1 : -1;
      const copy = items.slice();
      if (by === 'created'){
        copy.sort((a,b)=> (a.createdAt - b.createdAt) * order);
      } else if (by === 'name'){
        copy.sort((a,b)=> a.name.localeCompare(b.name, undefined, {numeric:true}) * order);
      }
      return copy;
    }

    function stripExtension(filename){
      if (!filename) return filename;
      const lastDot = filename.lastIndexOf('.');
      if (lastDot > 0) {
        return filename.substring(0, lastDot);
      }
      return filename;
    }

    // 文字列を検索用に正規化する
    // - NFKC 正規化（半角全角等を揃える）
    // - ASCII は小文字化
    // - カタカナをひらがなに変換（ひらがな/カタカナを同一視）
    function katakanaToHiragana(s){
      // U+30A1..U+30F6 -> subtract 0x60 to map to U+3041..U+3096
      return s.replace(/[\u30A1-\u30F6]/g, c => String.fromCharCode(c.charCodeAt(0) - 0x60));
    }
    function normalizeForSearch(s){
      if (!s) return '';
      try {
        let t = String(s);
        t = t.normalize('NFKC'); // 半角全角を統一
        t = t.toLowerCase(); // 英字の大小を無視
        t = katakanaToHiragana(t); // カタカナ→ひらがな
        return t;
      } catch (err) { return String(s).toLowerCase(); }
    }

    // カテゴリ編集モーダルの描画（並び替えボタンを追加）
    function openCategoryEditor(){
      // modalUsers をローカルに用意して編集用に使う（保存は閉じる時に一括）
      modalUsers = loadUserCategories().slice(); // copy
      categoryEditorContent.innerHTML = '';

      function renderRows(){
        categoryEditorContent.innerHTML = '';
        if (modalUsers.length === 0) {
          const p = document.createElement('div'); p.style.color='#666'; p.textContent = '編集できる項目はありません';
          categoryEditorContent.appendChild(p);
        } else {
          modalUsers.forEach((c, idx)=>{
            const row = document.createElement('div'); row.className = 'cat-row';
            // store id for later bulk-save on close
            row.dataset.catId = c.id;

            const upBtn = document.createElement('button'); upBtn.className='reorder-btn'; upBtn.textContent='↑'; upBtn.title='上へ';
            const downBtn = document.createElement('button'); downBtn.className='reorder-btn'; downBtn.textContent='↓'; downBtn.title='下へ';
            const nameIn = document.createElement('input'); nameIn.type = 'text'; nameIn.value = c.name || '';
            const colorIn = document.createElement('input'); colorIn.type = 'color'; colorIn.value = (c.color && c.color.length===4)? expandHex(c.color) : (c.color || '#ffffff');
            const delBtn = document.createElement('button'); delBtn.className='small-btn'; delBtn.textContent='削除';
            row.appendChild(upBtn); row.appendChild(downBtn); row.appendChild(nameIn); row.appendChild(colorIn); row.appendChild(delBtn);
            categoryEditorContent.appendChild(row);

            // disable up/down where appropriate
            if (idx === 0) upBtn.disabled = true;
            if (idx === modalUsers.length - 1) downBtn.disabled = true;

            upBtn.addEventListener('click', (e)=>{
              e.stopPropagation();
              if (idx > 0){
                const tmp = modalUsers[idx-1];
                modalUsers[idx-1] = modalUsers[idx];
                modalUsers[idx] = tmp;
                renderRows();
                // immediate save on move
                saveModalUsersAndRefresh();
              }
            });
            downBtn.addEventListener('click', (e)=>{
              e.stopPropagation();
              if (idx < modalUsers.length - 1){
                const tmp = modalUsers[idx+1];
                modalUsers[idx+1] = modalUsers[idx];
                modalUsers[idx] = tmp;
                renderRows();
                // immediate save on move
                saveModalUsersAndRefresh();
              }
            });

            delBtn.addEventListener('click', (e)=>{
              e.stopPropagation();
              if (!confirm('この項目を削除しますか？ 削除するとその項目に属していたファイルは「未分類」に戻ります。')) return;
              // call deleteCategory to handle DB reassignment and saved list
              deleteCategory(c.id);
              // also remove from modalUsers if present
              const i = modalUsers.findIndex(x => x.id === c.id);
              if (i >= 0) modalUsers.splice(i, 1);
              renderRows();
              // save modalUsers after deletion
              saveModalUsersAndRefresh();
            });

            // live-edit name/color locally so that closing will pick up changes
            nameIn.addEventListener('input', (ev)=>{
              const i = modalUsers.findIndex(x => x.id === c.id);
              if (i >= 0) modalUsers[i].name = nameIn.value;
              // immediate save on edit
              saveModalUsersAndRefresh();
            });
            colorIn.addEventListener('input', (ev)=>{
              const i = modalUsers.findIndex(x => x.id === c.id);
              let v = colorIn.value || '#ffffff';
              if (!v.startsWith('#')) v = '#' + v;
              v = v.toLowerCase();
              if (!isValidHexColor(v)) v = '#ffffff';
              v = expandHex(v);
              if (i >= 0) modalUsers[i].color = v;
              // immediate save on color change
              saveModalUsersAndRefresh();
            });
          });
        }
      }

      renderRows();

      modalBackdrop.style.display = 'flex';
      modalBackdrop.setAttribute('aria-hidden','false');
    }

    function closeCategoryEditorModal(){
      modalBackdrop.style.display = 'none';
      modalBackdrop.setAttribute('aria-hidden','true');
    }

    async function renderHistory(){
      historyList.innerHTML = '';
      const items = await getHistory();

      const finalSorted = sortItems(items || []);

      // 選択中カテゴリでフィルタ
      const selectedCat = categorySelect.value || ALL_ID;
      const searchTerm = (historySearch && historySearch.value) ? historySearch.value.trim() : '';
      const qnorm = normalizeForSearch(searchTerm);

      const filtered = finalSorted.filter(item => {
        if (selectedCat === ALL_ID) {
          // pass
        } else {
          const cids = Array.isArray(item.categoryIds) ? item.categoryIds : (item.categoryId ? [item.categoryId] : []);
          if (selectedCat === UNCATEGORIZED_ID) {
            if (cids && cids.length > 0) return false;
          } else {
            if (!cids || !cids.includes(selectedCat)) return false;
          }
        }

        // 検索条件（タイトルのみ）: 補足（note）は検索対象に含めない
        if (qnorm && qnorm.length > 0) {
          const title = stripExtension(item.name || '');
          const tnorm = normalizeForSearch(title);
          // 部分一致
          if (!tnorm.includes(qnorm)) return false;
        }

        return true;
      });

      const final = filtered;

      // --- NEW: update history count display ---
      try {
        const total = Array.isArray(items) ? items.length : 0;
        const shown = Array.isArray(final) ? final.length : 0;
        if (historyCountEl) {
          historyCountEl.textContent = `${shown} / ${total} 件表示`;
        }
      } catch (e) { /* ignore */ }
      // --- end new ---

      if (!final || final.length === 0){ historyList.innerHTML = '<div style="color:#666;padding:8px">履歴はありません</div>'; return; }

      // カテゴリ一覧を入手して移動セレクトに使うため整形
      const users = loadUserCategories();
      const catList = [{id: ALL_ID, name:'全て'}, {id: UNCATEGORIZED_ID, name:'未分類'}, ...users];

      // map id -> {name,color}
      const catMap = {};
      for (const c of users){ catMap[c.id] = {name:c.name, color: c.color || '#ffffff'}; }

      // 履歴を表示（サムネイルは読み込まず非表示）
      for (const it of final){
        const el = document.createElement('div');
        el.className = 'history-item';

        const thumb = document.createElement('div'); thumb.className='thumb';
        thumb.style.display = 'none';

        const meta = document.createElement('div'); meta.className='meta';

        const nameWrap = document.createElement('div');
        nameWrap.className = 'title-row';
        const name = document.createElement('div');
        name.className='name';
        name.textContent = stripExtension(it.name);
        nameWrap.appendChild(name);

        // show tag chips after title (clickable to jump to that item)
        const chips = document.createElement('div');
        chips.className = 'tag-chips';
        const cids = Array.isArray(it.categoryIds) ? it.categoryIds : (it.categoryId ? [it.categoryId] : []);
        if (!cids || cids.length === 0){
          const chip = document.createElement('button');
          chip.className = 'tag-chip uncat';
          chip.textContent = '未分類';
          chip.title = '未分類 を表示';
          chip.addEventListener('click', (e)=>{
            e.stopPropagation();
            categorySelect.value = UNCATEGORIZED_ID;
            categorySelect.dispatchEvent(new Event('change', {bubbles:true}));
          });
          chips.appendChild(chip);
        } else {
          for (const cid of cids){
            const metaC = catMap[cid];
            if (metaC){
              const chip = document.createElement('button');
              chip.className = 'tag-chip';
              const col = metaC.color || '#ffffff';
              chip.style.background = col;
              chip.style.color = contrastingTextColor(col);
              chip.textContent = metaC.name || cid;
              chip.title = `${metaC.name} を表示`;
              chip.addEventListener('click', (e)=>{
                e.stopPropagation();
                categorySelect.value = cid;
                categorySelect.dispatchEvent(new Event('change', {bubbles:true}));
              });
              chips.appendChild(chip);
            } else {
              const chip = document.createElement('button');
              chip.className = 'tag-chip uncat';
              chip.textContent = '未分類';
              chip.title = '未分類 を表示';
              chip.addEventListener('click', (e)=>{
                e.stopPropagation();
                categorySelect.value = UNCATEGORIZED_ID;
                categorySelect.dispatchEvent(new Event('change', {bubbles:true}));
              });
              chips.appendChild(chip);
            }
          }
        }
        nameWrap.appendChild(chips);

        const sub = document.createElement('div'); sub.className = 'sub'; sub.textContent = formatBytes(it.size) + ' • ' + new Date(it.createdAt).toLocaleString();
        meta.appendChild(nameWrap); meta.appendChild(sub);

        const noteDiv = document.createElement('div'); noteDiv.className = 'note';
        noteDiv.textContent = it.note || '';
        meta.appendChild(noteDiv);

        const actions = document.createElement('div'); actions.className='history-actions';
        const openBtn = document.createElement('button'); openBtn.className='small-btn'; openBtn.textContent='開く';
        const delBtn = document.createElement('button'); delBtn.className='small-btn'; delBtn.textContent='削除';
        const editBtn = document.createElement('button'); editBtn.className='small-btn'; editBtn.textContent='名前編集';
        const editNoteBtn = document.createElement('button'); editNoteBtn.className='small-btn'; editNoteBtn.textContent='補足編集';

        // 移動用セレクト（複数選択） + 適用・キャンセルボタン（ユーザーが完了した時点で移動を実行）
        const moveWrap = document.createElement('div');
        moveWrap.style.marginTop = '6px';
        const moveSelect = document.createElement('select');
        moveSelect.className = 'sort-select';
        moveSelect.setAttribute('aria-label', '項目に移動（複数選択可）');
        moveSelect.setAttribute('multiple', 'multiple');
        // populate (exclude '全て' as it's not a target)
        const moveOptions = [{id: UNCATEGORIZED_ID, name:'未分類'}, ...users];
        for (const c of moveOptions){
          const o = document.createElement('option');
          o.value = c.id;
          o.textContent = c.name;
          moveSelect.appendChild(o);
        }
        // set current selections visually
        const currentCids = Array.isArray(it.categoryIds) ? it.categoryIds : (it.categoryId ? [it.categoryId] : []);
        if (!currentCids || currentCids.length === 0){
          for (const opt of moveSelect.options){
            if (opt.value === UNCATEGORIZED_ID) opt.selected = true;
          }
        } else {
          for (const opt of moveSelect.options){
            if (currentCids.includes(opt.value)) opt.selected = true;
          }
        }
        // apply / cancel buttons (ユーザーが完了した時点で移動を実行)
        const applyBtn = document.createElement('button'); applyBtn.className='small-btn'; applyBtn.textContent='移動を適用';
        const cancelBtn = document.createElement('button'); cancelBtn.className='small-btn'; cancelBtn.textContent='キャンセル';
        // hide the apply/cancel by default; show only when user changes selection
        applyBtn.style.display = 'none';
        cancelBtn.style.display = 'none';

        // detect selection changes to show buttons
        const originalSelected = Array.from(moveSelect.selectedOptions).map(o=>o.value).sort().join(',');
        moveSelect.addEventListener('change', (e)=>{
          const now = Array.from(moveSelect.selectedOptions).map(o=>o.value).sort().join(',');
          if (now !== originalSelected) {
            applyBtn.style.display = '';
            cancelBtn.style.display = '';
          } else {
            applyBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
          }
        });

        applyBtn.addEventListener('click', async (e)=>{
          e.stopPropagation();
          // disable UI to prevent double submissions
          applyBtn.disabled = true;
          cancelBtn.disabled = true;
          moveSelect.disabled = true;

          const opts = Array.from(moveSelect.selectedOptions).map(o=>o.value);
          // filtered: drop '未分類' sentinel from explicit assignments; UNCATEGORIZED -> []
          const filtered = opts.filter(v => v && v !== UNCATEGORIZED_ID);
          const newCatArr = filtered.length === 0 ? [] : filtered;

          try {
            // guard: read current entry and skip if same set (to avoid redundant writes & transient errors)
            const current = await getEntry(it.id);
            const existing = Array.isArray(current.categoryIds) ? current.categoryIds : (current.categoryId ? [current.categoryId] : []);
            if (arraysEqualAsSets(existing, newCatArr)) {
              // nothing to do
              applyBtn.style.display = 'none';
              cancelBtn.style.display = 'none';
              return;
            }
          } catch (err) {
            console.warn('applyBtn guard: 現在値取得でエラー', err);
            // 続行して更新を試みる
          }

          // use queue to serialize updates per entry to avoid race conditions
          enqueueUpdateEntryCategory(it.id, newCatArr).then(()=>{
            // re-enable and refresh
            applyBtn.disabled = false;
            cancelBtn.disabled = false;
            moveSelect.disabled = false;
            renderHistory();
          }).catch(err => {
            console.warn('カテゴリ更新失敗', err);
            alert('項目の移動に失敗しました');
            applyBtn.disabled = false;
            cancelBtn.disabled = false;
            moveSelect.disabled = false;
            renderHistory();
          });
        });

        cancelBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          // reset selections to original
          for (const opt of moveSelect.options){
            opt.selected = false;
          }
          if (!currentCids || currentCids.length === 0){
            for (const opt of moveSelect.options){
              if (opt.value === UNCATEGORIZED_ID) opt.selected = true;
            }
          } else {
            for (const opt of moveSelect.options){
              if (currentCids.includes(opt.value)) opt.selected = true;
            }
          }
          applyBtn.style.display = 'none';
          cancelBtn.style.display = 'none';
        });

        moveWrap.appendChild(moveSelect);
        moveWrap.appendChild(applyBtn);
        moveWrap.appendChild(cancelBtn);
        meta.appendChild(moveWrap);

        // 「開く」ボタン等
        openBtn.addEventListener('click', (e)=>{ e.stopPropagation(); openFromHistory(it.id); });
        delBtn.addEventListener('click', (e)=>{ e.stopPropagation(); if (confirm('この履歴を削除しますか？')) deleteEntry(it.id).then(renderHistory); });

        editBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          nameWrap.innerHTML = '';
          const input = document.createElement('input'); input.className='name-input'; input.value = it.name;
          input.setAttribute('aria-label', 'ファイル名編集');
          const saveBtn = document.createElement('button'); saveBtn.className='small-btn'; saveBtn.textContent='保存';
          const cancelBtn2 = document.createElement('button'); cancelBtn2.className='small-btn'; cancelBtn2.textContent='キャンセル';
          const editControls = document.createElement('div'); editControls.className='edit-controls'; editControls.appendChild(saveBtn); editControls.appendChild(cancelBtn2);

          nameWrap.appendChild(input); nameWrap.appendChild(editControls);
          input.focus();

          function finishSave(){
            const newName = input.value.trim() || it.name;
            updateEntryName(it.id, newName).then(()=>{
              renderHistory();
            }).catch((err)=>{ console.warn('名前更新失敗', err); alert('名前の更新に失敗しました'); renderHistory(); });
          }
          function finishCancel(){ renderHistory(); }

          saveBtn.addEventListener('click', (ev)=>{ ev.stopPropagation(); finishSave(); });
          cancelBtn2.addEventListener('click', (ev)=>{ ev.stopPropagation(); finishCancel(); });

          input.addEventListener('keydown', (ev)=>{
            if (ev.key === 'Enter') { ev.preventDefault(); finishSave(); }
            if (ev.key === 'Escape') { ev.preventDefault(); finishCancel(); }
          });
        });

        // 補足編集
        editNoteBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          const originalNote = it.note || '';
          const noteEditWrap = document.createElement('div');
          const ta = document.createElement('textarea');
          ta.className = 'note-input';
          ta.value = originalNote;
          ta.setAttribute('aria-label', '補足編集');
          const saveBtn = document.createElement('button'); saveBtn.className='small-btn'; saveBtn.textContent='保存';
          const cancelBtn3 = document.createElement('button'); cancelBtn3.className='small-btn'; cancelBtn3.textContent='キャンセル';
          const editControls = document.createElement('div'); editControls.className='edit-controls'; editControls.appendChild(saveBtn); editControls.appendChild(cancelBtn3);

          noteEditWrap.appendChild(ta);
          noteEditWrap.appendChild(editControls);

          noteDiv.innerHTML = '';
          noteDiv.appendChild(noteEditWrap);
          ta.focus();

          function finishSave(){
            const newNote = ta.value;
            updateEntryNote(it.id, newNote).then(()=>{
              renderHistory();
            }).catch((err)=>{ console.warn('補足更新失敗', err); alert('補足の更新に失敗しました'); renderHistory(); });
          }
          function finishCancel(){ renderHistory(); }

          saveBtn.addEventListener('click', (ev)=>{ ev.stopPropagation(); finishSave(); });
          cancelBtn3.addEventListener('click', (ev)=>{ ev.stopPropagation(); finishCancel(); });

          ta.addEventListener('keydown', (ev)=>{
            if (ev.key === 'Escape') { ev.preventDefault(); finishCancel(); }
          });
        });

        actions.appendChild(openBtn);
        actions.appendChild(delBtn);
        actions.appendChild(editBtn);
        actions.appendChild(editNoteBtn);

        el.appendChild(thumb); el.appendChild(meta); el.appendChild(actions);
        historyList.appendChild(el);
      }
    }

    sortBySelect.addEventListener('change', ()=>{
      sortSettings.by = sortBySelect.value;
      saveSortSettings(sortSettings);
      renderHistory();
    });
    sortOrderSelect.addEventListener('change', ()=>{
      sortSettings.order = sortOrderSelect.value;
      saveSortSettings(sortSettings);
      renderHistory();
    });

    clearHistoryBtn.addEventListener('click', async ()=>{
      if (!confirm('履歴を全て消去しますか？')) return;
      try {
        await clearHistory();
        renderHistory();
      } catch (err) {
        alert('履歴消去中にエラーが発生しました');
      }
    });

    // カテゴリ選択の変更で再描画
    categorySelect.addEventListener('change', ()=>{
      renderHistory();
    });

    // 検索イベント
    if (historySearch) {
      historySearch.addEventListener('input', (e)=>{
        renderHistory();
      });
    }
    if (clearSearchBtn) {
      clearSearchBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        if (historySearch) {
          historySearch.value = '';
          historySearch.focus();
          renderHistory();
        }
      });
    }

    // 項目編集モーダル
    editCategoryBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      openCategoryEditor();
    });

    // モーダル内の「追加」ボタン（新しい行を modalUsers に追加して再描画）
    addCategoryInModal.addEventListener('click', (e)=>{
      e.stopPropagation();
      if (!modalUsers) modalUsers = loadUserCategories().slice();
      const id = 'cat_new_' + Date.now() + '_' + Math.floor(Math.random()*1000);
      const name = '';
      modalUsers.push({ id, name, color: '#ffffff', createdAt: Date.now() });
      // immediate save after adding
      saveModalUsersAndRefresh();

      // re-render modal
      (function renderModalRows(){
        categoryEditorContent.innerHTML = '';
        if (!modalUsers || modalUsers.length === 0){
          const p = document.createElement('div'); p.style.color='#666'; p.textContent = '編集できる項目はありません';
          categoryEditorContent.appendChild(p);
          return;
        }
        modalUsers.forEach((c, idx)=>{
          const row = document.createElement('div'); row.className = 'cat-row';
          row.dataset.catId = c.id;
          const upBtn = document.createElement('button'); upBtn.className='reorder-btn'; upBtn.textContent='↑'; upBtn.title='上へ';
          const downBtn = document.createElement('button'); downBtn.className='reorder-btn'; downBtn.textContent='↓'; downBtn.title='下へ';
          const nameIn = document.createElement('input'); nameIn.type = 'text'; nameIn.value = c.name || '';
          const colorIn = document.createElement('input'); colorIn.type = 'color'; colorIn.value = (c.color && c.color.length===4)? expandHex(c.color) : (c.color || '#ffffff');
          const delBtn = document.createElement('button'); delBtn.className='small-btn'; delBtn.textContent='削除';
          row.appendChild(upBtn); row.appendChild(downBtn); row.appendChild(nameIn); row.appendChild(colorIn); row.appendChild(delBtn);
          categoryEditorContent.appendChild(row);

          if (idx === 0) upBtn.disabled = true;
          if (idx === modalUsers.length - 1) downBtn.disabled = true;

          upBtn.addEventListener('click', (ev)=>{
            ev.stopPropagation();
            if (idx > 0){
              const tmp = modalUsers[idx-1];
              modalUsers[idx-1] = modalUsers[idx];
              modalUsers[idx] = tmp;
              renderModalRows();
              saveModalUsersAndRefresh();
            }
          });
          downBtn.addEventListener('click', (ev)=>{
            ev.stopPropagation();
            if (idx < modalUsers.length - 1){
              const tmp = modalUsers[idx+1];
              modalUsers[idx+1] = modalUsers[idx];
              modalUsers[idx] = tmp;
              modalUsers[idx] = tmp;
              renderModalRows();
              saveModalUsersAndRefresh();
            }
          });
          delBtn.addEventListener('click', (ev)=>{
            ev.stopPropagation();
            if (!confirm('この項目を削除しますか？ 削除するとその項目に属していたファイルは「未分類」に戻ります。')) return;
            deleteCategory(c.id);
            const i = modalUsers.findIndex(x => x.id === c.id);
            if (i >= 0) modalUsers.splice(i,1);
            renderModalRows();
            saveModalUsersAndRefresh();
          });
          nameIn.addEventListener('input', (ev)=>{
            const i = modalUsers.findIndex(x => x.id === c.id);
            if (i >= 0) modalUsers[i].name = nameIn.value;
            saveModalUsersAndRefresh();
          });
          colorIn.addEventListener('input', (ev)=>{
            const i = modalUsers.findIndex(x => x.id === c.id);
            let v = colorIn.value || '#ffffff';
            if (!v.startsWith('#')) v = '#' + v;
            v = v.toLowerCase();
            if (!isValidHexColor(v)) v = '#ffffff';
            v = expandHex(v);
            if (i >= 0) modalUsers[i].color = v;
            saveModalUsersAndRefresh();
          });
        });
      })();
    });

    // 閉じるボタン：モーダル内の変更をまとめて保存して閉じる（自動保存）
    closeCategoryEditor.addEventListener('click', (e)=>{
      e.stopPropagation();
      try {
        if (Array.isArray(modalUsers)) {
          // 保存: modalUsers をそのまま保存（順序も反映）
          saveUserCategories(modalUsers);
        } else {
          // fallback: try to collect from DOM rows (旧ロジック互換)
          const rows = Array.from(categoryEditorContent.querySelectorAll('.cat-row'));
          if (rows.length > 0) {
            const users = loadUserCategories();
            const mapById = {};
            for (const u of users) mapById[u.id] = u;

            let changed = false;
            const newUsers = [];
            for (const row of rows) {
              const id = row.dataset.catId || ('cat_' + Date.now() + '_' + Math.floor(Math.random()*1000));
              const nameInput = row.querySelector('input[type="text"]');
              const colorInput = row.querySelector('input[type="color"]');
              const newName = nameInput ? (nameInput.value.trim() || mapById[id]?.name || '') : (mapById[id]?.name || '');
              let newColor = colorInput ? (colorInput.value || '#ffffff') : (mapById[id]?.color || '#ffffff');
              if (!newColor.startsWith('#')) newColor = '#' + newColor;
              newColor = newColor.toLowerCase();
              if (!isValidHexColor(newColor)) newColor = '#ffffff';
              newColor = expandHex(newColor);

              if (mapById[id]) {
                if (mapById[id].name !== newName || (mapById[id].color || '') !== newColor) {
                  mapById[id].name = newName;
                  mapById[id].color = newColor;
                  changed = true;
                }
                newUsers.push(mapById[id]);
              } else {
                newUsers.push({ id, name: newName, color: newColor, createdAt: Date.now() });
                changed = true;
              }
            }
            saveUserCategories(newUsers);
          }
        }
      } catch (err) {
        console.warn('カテゴリ保存中にエラー', err);
      }
      // refresh UI and close modal
      populateCategorySelect();
      renderHistory();
      closeCategoryEditorModal();
    });

    modalBackdrop.addEventListener('click', (e)=>{
      if (e.target === modalBackdrop) closeCategoryEditorModal();
    });

    function preventTouchScroll(e){
      if ((overlayRight && overlayRight.contains(e.target)) || (topBack && topBack.contains(e.target)) || (topSeek && topSeek.contains(e.target)) || (topToggle && topToggle.contains(e.target))) return;
      e.preventDefault();
      e.stopPropagation();
    }

    function adjustTopSeek() {
      try {
        const margin = 8;
        const baseLeftMin = 12;
        if (topBack) topBack.style.left = baseLeftMin + 'px';
        if (skipGroup) {
          skipGroup.style.left = baseLeftMin + 'px';
        }

        let leftEdge = baseLeftMin;
        try {
          const bRect = topBack.getBoundingClientRect();
          leftEdge = Math.max(leftEdge, Math.round(bRect.right + margin));
        } catch (e){}

        try {
          const sRect = skipGroup.getBoundingClientRect();
          if (sRect.width > 0) leftEdge = Math.max(leftEdge, Math.round(sRect.right + margin));
          if (topBack) {
            const backRect = topBack.getBoundingClientRect();
            skipGroup.style.top = Math.round(backRect.bottom + 6) + 'px';
          }
        } catch (e){}

        let rightEdge = 12;
        try {
          const tRect = topToggle.getBoundingClientRect();
          rightEdge = Math.max(12, Math.round(window.innerWidth - tRect.left + margin));
        } catch (e){}

        const minSeekWidth = 180;
        const available = window.innerWidth - leftEdge - rightEdge;
        if (available < minSeekWidth) {
          const deficit = minSeekWidth - available;
          const reduceLeft = Math.ceil(deficit / 2);
          const reduceRight = Math.floor(deficit / 2);
          leftEdge = Math.max(6, leftEdge - reduceLeft);
          rightEdge = Math.max(6, rightEdge - reduceRight);
        }

        if (topSeek) {
          topSeek.style.left = leftEdge + 'px';
          topSeek.style.right = rightEdge + 'px';
        }

        repositionMarkerLayer();
      } catch (err) {
        if (topSeek) { topSeek.style.left = ''; topSeek.style.right = ''; }
      }
    }

    window.addEventListener('resize', () => { adjustTopSeek(); renderMarkers(); });
    window.addEventListener('orientationchange', () => { setTimeout(adjustTopSeek, 80); setTimeout(renderMarkers, 100); });
    window.addEventListener('load', () => { setTimeout(adjustTopSeek, 120); setTimeout(renderMarkers, 140); });

    async function openViewer(autoPlay = false){
      if (!currentObjectUrl) return;
      pickerScreen.style.display = 'none';
      viewer.style.display = 'block';
      viewer.setAttribute('aria-hidden','false');

      // hide reload button on viewer screen
      if (reloadBtn) reloadBtn.style.display = 'none';

      video.controls = false;

      video.addEventListener('touchstart', (e) => { e.stopPropagation(); }, {passive:false});
      video.addEventListener('touchend', (e) => { e.stopPropagation(); }, {passive:false});
      video.addEventListener('touchmove', preventTouchScroll, {passive:false});
      video.addEventListener('click', (e) => { e.stopPropagation(); }, {passive:false});
      video.addEventListener('dblclick', (e) => { e.stopPropagation(); }, {passive:false});

      videoWrap.addEventListener('touchstart', (e) => { e.stopPropagation(); }, {passive:false});
      videoWrap.addEventListener('touchend', (e) => { e.stopPropagation(); }, {passive:false});
      videoWrap.addEventListener('touchmove', preventTouchScroll, {passive:false});

      if (autoPlay) {
        try { await video.play(); } catch (err) { console.warn('自動再生できませんでした:', err); }
      }

      updateToggleButton();
      updateSpeedDisplay();

      setTimeout(adjustTopSeek, 60);
      setTimeout(adjustTopSeek, 300);
    }

    // pickBtn: 既存の <input> を開く
    pickBtn.addEventListener('click', (e) => { e.stopPropagation(); fileInput.click(); });

    /**
     * 変更点（要件反映）:
     * - 複数選択をサポート (input に multiple を追加済み)
     * - ファイル選択後に「自動でビューアに遷移しない」ようにし、選択したファイルを履歴に追加する動作に変更
     * - ドラッグ＆ドロップでアップロード（履歴に追加）できるように pickerScreen にイベントを追加
     * - 進捗 UI を追加（各ファイルごとにインデックス表示）
     * - 各ファイルごとにキャンセル可能にした（uploadControllers を通じて中断）
     */

    // ---------- ここから：進捗UI用ユーティリティ ----------
    function createProgressItem(fileName, fileSize, index){
      // ensure container visible
      if (uploadProgressContainer) uploadProgressContainer.style.display = '';

      const item = document.createElement('div');
      item.className = 'progress-item';
      item.setAttribute('role','listitem');

      const idx = document.createElement('div');
      idx.className = 'index-badge';
      idx.textContent = String(index);

      const main = document.createElement('div');
      main.className = 'progress-main';

      const title = document.createElement('div');
      title.className = 'progress-title';
      title.textContent = fileName;
      title.title = fileName;

      const row = document.createElement('div');
      row.className = 'progress-row';

      const barBg = document.createElement('div');
      barBg.className = 'progress-bar-bg';
      const barFill = document.createElement('div');
      barFill.className = 'progress-bar-fill';
      barBg.appendChild(barFill);

      const meta = document.createElement('div');
      meta.className = 'progress-meta';
      const percent = document.createElement('div');
      percent.className = 'progress-percent';
      percent.textContent = '0%';
      const size = document.createElement('div');
      size.className = 'progress-size';
      size.textContent = formatBytes(fileSize);

      meta.appendChild(percent);
      meta.appendChild(size);

      row.appendChild(barBg);
      row.appendChild(meta);

      main.appendChild(title);
      main.appendChild(row);

      // cancel button
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'small-btn progress-cancel-btn';
      cancelBtn.textContent = 'キャンセル';
      cancelBtn.title = 'このファイルのアップロードをキャンセルします';

      item.appendChild(idx);
      item.appendChild(main);
      item.appendChild(cancelBtn);

      uploadProgressList.appendChild(item);

      return {
        el: item,
        cancelBtn,
        setPercent(p){
          const pp = Math.max(0, Math.min(100, Math.round(p)));
          barFill.style.width = pp + '%';
          percent.textContent = pp + '%';
        },
        setTitle(t){
          try { title.textContent = t; title.title = t; } catch(e){}
        },
        markDone(){
          this.setPercent(100);
          item.classList.add('done');
          // hide cancel button on success
          try { cancelBtn.style.display = 'none'; } catch(e){}
        },
        markError(msg){
          item.classList.add('error');
          if (msg && typeof msg === 'string') {
            this.setTitle(title.textContent + ' — ' + msg);
          }
          try { cancelBtn.style.display = 'none'; } catch(e){}
        },
        markCancelled(){
          item.classList.add('cancelled');
          item.classList.add('error');
          this.setPercent(0);
          try { cancelBtn.style.display = 'none'; } catch(e){}
          this.setTitle(title.textContent + ' — キャンセルされました');
        },
        remove(){
          try { uploadProgressList.removeChild(item); } catch(e){}
          // hide container if empty
          if (uploadProgressList.children.length === 0) {
            uploadProgressContainer.style.display = 'none';
          }
        }
      };
    }

    /**
     * saveFileToHistoryWithProgress:
     * - UI 用にチャンク読みして進捗を報告（既存の saveFileToHistory をそのまま呼ぶ）
     * - options.signal: { aborted: boolean } をチェックして中断できる（簡易な AbortSignal）
     *
     * 注意: チャンク読みは UI のためのもので、DB 保存とは別工程です。
     */
    async function saveFileToHistoryWithProgress(file, progressCallback, options = {}){
      try {
        if (progressCallback) progressCallback(0);
        const CHUNK = 256 * 1024; // 256KB
        let offset = 0;
        const sig = options.signal;
        if (file.size > 0) {
          while (offset < file.size) {
            // check cancellation before reading next chunk
            if (sig && sig.aborted) {
              // stop early
              throw new DOMException('Upload aborted', 'AbortError');
            }
            const end = Math.min(offset + CHUNK, file.size);
            const chunk = file.slice(offset, end);
            // read chunk (ArrayBuffer) — we don't use data, this is just to report progress
            await new Promise((resolve) => {
              const fr = new FileReader();
              fr.onload = () => resolve();
              fr.onerror = () => {
                // in case of error, resolve to continue (we don't want to block)
                resolve();
              };
              fr.readAsArrayBuffer(chunk);
            });
            offset = end;
            // report up to 95% for chunk reading progress (leave final part for DB write)
            if (progressCallback) {
              const frac = offset / file.size;
              const pct = Math.round(Math.min(95, Math.max(1, frac * 90)));
              progressCallback(pct);
            }
            // check cancellation after read
            if (sig && sig.aborted) {
              throw new DOMException('Upload aborted', 'AbortError');
            }
          }
        }
        // check once more before heavy DB work
        if (sig && sig.aborted) {
          throw new DOMException('Upload aborted', 'AbortError');
        }
        // Now call the original save function (this may take time for IndexedDB)
        const id = await saveFileToHistory(file);
        if (progressCallback) progressCallback(100);
        return id;
      } catch (err) {
        if (err && err.name === 'AbortError') {
          // rethrow or return a specific value the caller will interpret as canceled
          throw err;
        }
        if (progressCallback) progressCallback(100);
        console.warn('saveFileToHistoryWithProgress error', err);
        throw err;
      }
    }
    // ---------- ここまで：進捗UI用ユーティリティ ----------

    // ファイル選択（複数対応）：選択したファイルを履歴に追加し画面遷移しない
    fileInput.addEventListener('change', async () => {
      const files = fileInput.files;
      if (!files || files.length === 0) {
        fileNameEl.textContent = 'まだファイルが選択されていません';
        // hide progress UI if no files
        try { uploadProgressContainer.style.display = 'none'; uploadProgressList.innerHTML = ''; } catch(e){}
        return;
      }

      // 表示は簡易に（単数は詳細、複数は個数表示）
      if (files.length === 1) {
        const f = files[0];
        fileNameEl.textContent = f.name + ' (' + Math.round(f.size/1024) + ' KB)';
      } else {
        fileNameEl.textContent = `${files.length} 個のファイルが選択されました`;
      }

      // 保存処理（順次） — 進捗 UI を追加
      const savedIds = [];
      // clear previous progress items if any
      uploadProgressList.innerHTML = '';
      uploadProgressContainer.style.display = '';

      const fileArr = Array.from(files);
      // create controllers for each file so user can cancel while queued or uploading
      const taskIds = fileArr.map((f, i) => 'task_' + Date.now() + '_' + i + '_' + Math.floor(Math.random()*1000));
      for (let i = 0; i < fileArr.length; i++) {
        const f = fileArr[i];
        const idx = i + 1;
        const taskId = taskIds[i];
        const ui = createProgressItem(stripExtension(f.name), f.size, idx);

        // controller: simple abort flag
        const controller = { aborted: false };
        uploadControllers.set(taskId, controller);

        // wire up cancel button
        ui.cancelBtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (controller.aborted) return;
          controller.aborted = true;
          // visually mark cancelling
          ui.setTitle(stripExtension(f.name) + ' — キャンセル中...');
          ui.setPercent(0);
          ui.cancelBtn.disabled = true;
        });

        try {
          // check if already cancelled before starting
          if (controller.aborted) {
            ui.markCancelled();
            uploadControllers.delete(taskId);
            continue;
          }

          const id = await saveFileToHistoryWithProgress(f, (pct) => {
            try { ui.setPercent(pct); } catch(e){}
          }, { signal: controller });

          if (id) {
            savedIds.push(id);
            ui.markDone();
            // small delay so user sees 100% state
            await new Promise(r=>setTimeout(r, 120));
            // leave completed item visible (user can inspect)
          } else {
            ui.markError('保存されませんでした');
          }
        } catch (err) {
          if (err && err.name === 'AbortError') {
            ui.markCancelled();
          } else {
            console.warn('ファイル保存中にエラー', err);
            try { ui.markError('エラー'); } catch(e){}
          }
        } finally {
          uploadControllers.delete(taskId);
        }
      }

      // 入力をクリアして同じファイルを再度選べるようにする
      try { fileInput.value = ''; } catch(e){}

      // 最後に履歴を更新（自動でビューアへは遷移しない）
      if (savedIds.length > 0) {
        currentHistoryId = savedIds[savedIds.length - 1];
      }
      renderHistory();

      // 全てのファイル処理が終わったら進捗バーを画面から消す（要求通り）
      try {
        uploadProgressContainer.style.display = 'none';
        uploadProgressList.innerHTML = '';
      } catch (e) { console.warn('upload progress hide failed', e); }
    });

    // ドラッグ＆ドロップ対応: pickerScreen 上でのドロップを受けてファイルを履歴へ追加
    pickerScreen.addEventListener('dragover', (e) => {
      e.preventDefault();
      try { e.dataTransfer.dropEffect = 'copy'; } catch (err) {}
      pickerScreen.classList.add('dragover');
    }, {passive:false});
    pickerScreen.addEventListener('dragleave', (e) => {
      pickerScreen.classList.remove('dragover');
    });
    pickerScreen.addEventListener('drop', async (e) => {
      e.preventDefault();
      pickerScreen.classList.remove('dragover');
      const dt = e.dataTransfer;
      if (!dt) return;
      const files = dt.files;
      if (!files || files.length === 0) return;

      if (files.length === 1) {
        const f = files[0];
        fileNameEl.textContent = f.name + ' (' + Math.round(f.size/1024) + ' KB)';
      } else {
        fileNameEl.textContent = `${files.length} 個のファイルをドロップしました`;
      }

      const savedIds = [];
      // clear previous progress items if any
      uploadProgressList.innerHTML = '';
      uploadProgressContainer.style.display = '';

      const fileArr = Array.from(files);
      const taskIds = fileArr.map((f, i) => 'task_' + Date.now() + '_' + i + '_' + Math.floor(Math.random()*1000));
      for (let i = 0; i < fileArr.length; i++) {
        const f = fileArr[i];
        const idx = i + 1;
        const taskId = taskIds[i];
        const ui = createProgressItem(stripExtension(f.name), f.size, idx);

        const controller = { aborted: false };
        uploadControllers.set(taskId, controller);

        ui.cancelBtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (controller.aborted) return;
          controller.aborted = true;
          ui.setTitle(stripExtension(f.name) + ' — キャンセル中...');
          ui.setPercent(0);
          ui.cancelBtn.disabled = true;
        });

        try {
          if (controller.aborted) {
            ui.markCancelled();
            uploadControllers.delete(taskId);
            continue;
          }

          const id = await saveFileToHistoryWithProgress(f, (pct) => {
            try { ui.setPercent(pct); } catch(e){}
          }, { signal: controller });

          if (id) {
            savedIds.push(id);
            ui.markDone();
            await new Promise(r=>setTimeout(r, 120));
          } else {
            ui.markError('保存されませんでした');
          }
        } catch (err) {
          if (err && err.name === 'AbortError') {
            ui.markCancelled();
          } else {
            console.warn('ドロップファイル保存失敗', err);
            try { ui.markError('エラー'); } catch(e){}
          }
        } finally {
          uploadControllers.delete(taskId);
        }
      }
      if (savedIds.length > 0) {
        currentHistoryId = savedIds[savedIds.length - 1];
      }
      renderHistory();

      // 全てのファイル処理が終わったら進捗バーを画面から消す（要求通り）
      try {
        uploadProgressContainer.style.display = 'none';
        uploadProgressList.innerHTML = '';
      } catch (e) { console.warn('upload progress hide failed', e); }
    }, {passive:false});

    async function openFromHistory(id){
      const entry = await getEntry(id);
      if (!entry) return alert('履歴が見つかりませんでした');

      if (!entry.blob) {
        alert('この履歴は容量節約のため動画本体が保存されていません（再度ファイルを開いてください）');
        return;
      }

      if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }
      currentObjectUrl = URL.createObjectURL(entry.blob);
      video.src = currentObjectUrl;
      video.load();
      video.playbackRate = 1.0;
      currentHistoryId = entry.id;
      fileNameEl.textContent = entry.name + ' (' + Math.round(entry.size/1024) + ' KB)';

      // --- 変更: DB に保存してあるマーカーを読み込んで反映 ---
      markers = Array.isArray(entry.markers) ? entry.markers.slice() :
            (Array.isArray(entry.markerTimes) ? entry.markerTimes.slice() : []);
      // --- end change ---

      clearMarkerElements();

      await openViewer(true);
    }

    async function togglePlay() {
      if (video.paused || video.ended) {
        try { await video.play(); } catch (err) { console.warn('再生できませんでした:', err); alert('再生できませんでした。ページの許可や操作を確認してください。'); }
      } else {
        video.pause();
      }
      updateToggleButton();
      setTimeout(adjustTopSeek, 30);
    }

    function updateToggleButton() {
      if (video.paused || video.ended) {
        playToggleBtn.textContent = '再生';
        playToggleBtn.setAttribute('aria-pressed','false');
      } else {
        playToggleBtn.textContent = '停止';
        playToggleBtn.setAttribute('aria-pressed','true');
      }
    }

    playToggleBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePlay(); });

    function updateSpeedDisplay() { speedDisplay.textContent = video.playbackRate.toFixed(2) + 'x'; }
    function changeSpeed(delta) {
      let newRate = Math.round((video.playbackRate + delta) / SPEED_STEP) * SPEED_STEP;
      if (newRate < SPEED_MIN) newRate = SPEED_MIN;
      if (newRate > SPEED_MAX) newRate = SPEED_MAX;
      video.playbackRate = Number(newRate.toFixed(2));
      updateSpeedDisplay();
    }
    speedMinus.addEventListener('click', (e)=>{ e.stopPropagation(); changeSpeed(-SPEED_STEP); });
    speedPlus.addEventListener('click', (e)=>{ e.stopPropagation(); changeSpeed(SPEED_STEP); });

    function seekBy(deltaSec){
      if (!video.duration || !isFinite(video.duration)) return;
      let t = video.currentTime + deltaSec;
      if (t < 0) t = 0;
      if (t > video.duration) t = video.duration;
      video.currentTime = t;
    }

    back3Btn.addEventListener('click', (e)=>{ e.stopPropagation(); seekBy(-3); });
    back5Btn.addEventListener('click', (e)=>{ e.stopPropagation(); seekBy(-5); });
    fwd3Btn.addEventListener('click', (e)=>{ e.stopPropagation(); seekBy(3); });
    fwd5Btn.addEventListener('click', (e)=>{ e.stopPropagation(); seekBy(5); });

    [back3Btn,back5Btn,fwd3Btn,fwd5Btn].forEach(btn=>{
      if (btn) btn.addEventListener('touchend', (e)=>{ e.stopPropagation(); }, {passive:true});
    });

    if (mirrorBtn) {
      mirrorBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleMirror();
      });
      mirrorBtn.addEventListener('touchend', (e) => { e.stopPropagation(); }, {passive:true});
    }

    function toggleMirror(){
      const isNowMirrored = video.classList.toggle('mirrored');
      if (mirrorBtn) {
        mirrorBtn.setAttribute('aria-pressed', isNowMirrored ? 'true' : 'false');
      }
    }

    backBtn.addEventListener('click', async (e) => {
      e.stopPropagation();

      // --- 追加: 現在のマーカーを DB に保存（ファイル単位） ---
      try {
        if (currentHistoryId != null) {
          // ensure markers array is normalized numbers
          const normalized = Array.isArray(markers) ? markers.map(x=>Number(x)).filter(x=>isFinite(x)) : [];
          await updateEntryMarkers(currentHistoryId, normalized);
        }
      } catch (err) {
        console.warn('マーカーの保存に失敗しました', err);
        // 保存失敗でも画面を戻す（という仕様）
      }
      // --- 保存終了 ---

      video.pause();
      video.removeAttribute('src');
      video.load();

      if (currentObjectUrl) {
        URL.revokeObjectURL(currentObjectUrl);
        currentObjectUrl = null;
      }

      try {
        video.removeEventListener('touchmove', preventTouchScroll);
        videoWrap.removeEventListener('touchmove', preventTouchScroll);
      } catch (err){}

      viewer.style.display = 'none';
      viewer.setAttribute('aria-hidden','true');
      pickerScreen.style.display = 'flex';

      fileInput.value = '';
      fileNameEl.textContent = 'まだファイルが選択されていません';

      markers = [];
      clearMarkerElements();

      // ミラー状態リセット（見た目を統一）
      if (video.classList.contains('mirrored')) {
        video.classList.remove('mirrored');
        if (mirrorBtn) { mirrorBtn.setAttribute('aria-pressed','false'); }
      }

      // show reload button again when returning to picker screen
      if (reloadBtn) reloadBtn.style.display = '';
    });

    video.addEventListener('timeupdate', () => {
      if (!isSeeking && video.duration && isFinite(video.duration)) {
        const pct = (video.currentTime / video.duration) * 100;
        seekBar.value = pct;
      }
      updateToggleButton();
    });

    video.addEventListener('loadedmetadata', () => {
      seekBar.value = 0;
      updateToggleButton();
      renderMarkers();
    });

    seekBar.addEventListener('input', (e) => { isSeeking = true; });
    seekBar.addEventListener('change', (e) => {
      const pct = Number(seekBar.value);
      if (isFinite(video.duration) && video.duration > 0) {
        video.currentTime = (pct / 100) * video.duration;
      }
      isSeeking = false;
    });
    seekBar.addEventListener('click', (e)=>e.stopPropagation());
    seekBar.addEventListener('touchend', (e)=>e.stopPropagation(), {passive:true});

    video.addEventListener('play', updateToggleButton);
    video.addEventListener('pause', updateToggleButton);
    video.addEventListener('ended', updateToggleButton);

    function tryStartOnTap(e){
      if (!(video.paused || video.ended)) return;
      if ((topBack && topBack.contains(e.target)) || (topSeek && topSeek.contains(e.target)) || (topToggle && topToggle.contains(e.target)) || (overlayRight && overlayRight.contains(e.target)) || (skipGroup && skipGroup.contains(e.target))) {
        return;
      }
      video.play().catch(()=>{});
      updateToggleButton();
    }

    viewer.addEventListener('click', tryStartOnTap);
    viewer.addEventListener('touchend', tryStartOnTap, {passive:true});

    pickBtn.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') fileInput.click();
    });

    if (reloadBtn) {
      reloadBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm('ページを再読み込みしますか？ 開いている動画や未保存の変更は失われます。')) {
          location.reload();
        }
      });
    }

    /**
     * 新規: キャッシュ削除処理（進捗表示 + キャンセル対応）
     *
     * 挙動:
     *  - ユーザーが「キャッシュ削除」を押すと確認ダイアログ → 進捗オーバーレイを表示して段階的に削除処理を実行
     *  - 処理中に「キャンセル」を押すと以後のステップをスキップ（既に行われた操作は取り消せない点に注意）
     *  - 完了後は UI を更新（カテゴリセレクト、履歴再描画）
     */
    if (clearCacheBtn) {
      clearCacheBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (!confirm('アプリ内のキャッシュ（保存された動画データなど）を完全に削除しますか？ この操作は元に戻せません。')) return;

        // simple controller
        const controller = { aborted: false };

        // show overlay
        cacheOverlay.setAttribute('aria-hidden', 'false');
        cacheOverlayTitle.textContent = 'キャッシュを削除しています…';
        cacheOverlayMsg.textContent = '準備中';
        cacheProgressFill.style.width = '6%';
        cacheCancelBtn.disabled = false;
        cacheCloseBtn.style.display = 'none';

        // cancel handler
        const onCancel = () => {
          controller.aborted = true;
          cacheOverlayMsg.textContent = 'キャンセル中…処理を停止します';
          cacheCancelBtn.disabled = true;
        };
        cacheCancelBtn.addEventListener('click', onCancel, { once: true });

        // helper to update progress and check abort
        function updateProgress(pct, msg) {
          try {
            cacheProgressFill.style.width = Math.max(0, Math.min(100, Math.round(pct))) + '%';
          } catch (e){}
          if (msg) cacheOverlayMsg.textContent = msg;
        }

        try {
          // Step 1: revoke object URLs and stop playback
          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(6, '再生中の動画を停止しています...');
          try {
            if (currentObjectUrl) {
              try { URL.revokeObjectURL(currentObjectUrl); } catch(e){}
              currentObjectUrl = null;
            }
            video.pause();
            video.removeAttribute('src');
            video.load();
            currentHistoryId = null;
          } catch (e) {}
          await new Promise(r => setTimeout(r, 140)); // small visual pause

          // Step 2: abort pending uploads
          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(18, '保留中のアップロードを中止しています...');
          try {
            for (const ctrl of uploadControllers.values()) {
              try { ctrl.aborted = true; } catch(e){}
            }
          } catch (e) {}
          await new Promise(r => setTimeout(r, 160));

          // Step 3: delete indexedDB database
          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(36, 'IndexedDB を削除しています...');
          try {
            await new Promise((resolve, reject) => {
              try {
                const delReq = indexedDB.deleteDatabase(DB_NAME);
                delReq.onsuccess = () => resolve();
                delReq.onerror = () => reject(delReq.error);
                delReq.onblocked = () => {
                  console.warn('deleteDatabase blocked');
                  resolve();
                };
              } catch (err) {
                reject(err);
              }
            });
            dbPromise = null;
            // quick reopen to reinitialize store shape
            try { await openDB(); } catch(e){ console.warn('openDB after delete failed', e); }
          } catch (err) {
            console.warn('IndexedDB 削除でエラー', err);
            // continue to try clearing caches
          }
          await new Promise(r => setTimeout(r, 180));

          // Step 4: clear Cache Storage (service worker caches)
          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(68, 'Cache Storage を削除しています...');
          if ('caches' in window) {
            try {
              const keys = await caches.keys();
              let i = 0;
              for (const k of keys) {
                if (controller.aborted) break;
                await caches.delete(k);
                i++;
                // update small incremental progress for each cache key
                const sub = 68 + Math.min(20, Math.round((i / Math.max(1, keys.length)) * 20));
                updateProgress(sub, `Cache "${k}" を削除中…`);
              }
            } catch (e) {
              console.warn('Cache Storage clear failed', e);
            }
          }
          await new Promise(r => setTimeout(r, 120));

          // Step 5: final UI refresh
          if (controller.aborted) throw new DOMException('Aborted', 'AbortError');
          updateProgress(92, 'ユーザーインターフェースを更新しています...');
          try {
            populateCategorySelect();
            await renderHistory();
          } catch (e) { console.warn('UI refresh failed', e); }
          await new Promise(r => setTimeout(r, 140));

          // finished
          updateProgress(100, '完了しました');
          cacheOverlayMsg.textContent = 'キャッシュを削除しました';
          cacheCancelBtn.style.display = 'none';
          cacheCloseBtn.style.display = '';
          cacheCloseBtn.disabled = false;

          cacheCloseBtn.addEventListener('click', () => {
            cacheOverlay.setAttribute('aria-hidden', 'true');
          }, { once: true });

          alert('アプリのキャッシュ（IndexedDB と Cache Storage）を削除しました。');
        } catch (err) {
          // aborted or error
          if (err && err.name === 'AbortError') {
            updateProgress(0, '処理はキャンセルされました');
            cacheCancelBtn.style.display = 'none';
            cacheCloseBtn.style.display = '';
            cacheCloseBtn.disabled = false;
            cacheCloseBtn.addEventListener('click', () => {
              cacheOverlay.setAttribute('aria-hidden', 'true');
            }, { once: true });
            alert('キャッシュ削除はキャンセルされました。途中まで行われた処理は取り消せません。');
          } else {
            console.warn('clearCache error', err);
            updateProgress(100, 'エラーが発生しました');
            cacheCancelBtn.style.display = 'none';
            cacheCloseBtn.style.display = '';
            cacheCloseBtn.disabled = false;
            cacheCloseBtn.addEventListener('click', () => {
              cacheOverlay.setAttribute('aria-hidden', 'true');
            }, { once: true });
            alert('キャッシュ削除中にエラーが発生しました: ' + (err && err.message ? err.message : 'Unknown'));
          }
        } finally {
          // cleanup: ensure button removed if still attached
          try { cacheCancelBtn.removeEventListener('click', onCancel); } catch(e){}
          // leave overlay visible until user closes (so they can read message)
        }
      });
    }

    window.addEventListener('beforeunload', () => {
      if (currentObjectUrl) URL.revokeObjectURL(currentObjectUrl);
    });

    (async ()=>{ try{ await openDB(); populateCategorySelect(); await renderHistory(); }catch(e){ console.warn(e); } })();

    function clearMarkerElements(){
      while (markerLayer.firstChild) markerLayer.removeChild(markerLayer.firstChild);
    }

    function renderMarkers(){
      clearMarkerElements();
      if (!markers || markers.length === 0) return;
      const dur = (video && isFinite(video.duration)) ? video.duration : null;
      if (!dur) return;

      const seekRect = seekBar.getBoundingClientRect();
      const layerRect = markerLayer.getBoundingClientRect();
      if (seekRect.width <= 0) return;

      const markerW = 2;
      const markerH = 12;

      markers.forEach((t, idx) => {
        const el = document.createElement('div');
        el.className = 'marker';
        el.setAttribute('role','presentation');
        el.setAttribute('aria-label', `マーカー ${formatTimeForLabel(t)}`);

        const frac = Math.max(0, Math.min(1, t / dur));
        const leftOnSeekPx = frac * seekRect.width;
        const leftPx = seekRect.left + leftOnSeekPx - layerRect.left - (markerW / 2);
        const topPx = (seekRect.top + (seekRect.height / 2)) - layerRect.top - (markerH / 2);

        el.style.left = `${Math.round(leftPx)}px`;
        el.style.top = `${Math.round(topPx)}px`;
        markerLayer.appendChild(el);
      });
    }

    markerAddBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (!video || !isFinite(video.duration)) { return; }
      const t = Number(video.currentTime || 0);
      const EPS = 0.1;
      const exist = markers.some(m => Math.abs(m - t) < EPS);
      if (exist) {
        return;
      }
      markers.push(t);
      markers.sort((a,b)=>a-b);
      renderMarkers();

      // 自動保存: 現在開いている履歴があれば即時保存
      try {
        if (currentHistoryId != null) {
          const normalized = Array.isArray(markers) ? markers.map(x=>Number(x)).filter(x=>isFinite(x)) : [];
          updateEntryMarkers(currentHistoryId, normalized).catch(err => console.warn('マーカー自動保存失敗', err));
        }
      } catch (err) { console.warn('marker add save err', err); }
    });

    function findPreviousMarkerIndex(referenceTime) {
      if (!markers || markers.length === 0) return -1;
      const EPS = 1e-6;
      let idx = -1;
      for (let i = 0; i < markers.length; i++){
        if (markers[i] <= referenceTime - EPS) idx = i;
        else break;
      }
      return idx;
    }

    markerJumpBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (!markers || markers.length === 0) return;
      if (!video || !isFinite(video.duration)) return;
      const ref = Number(video.currentTime || 0);
      const idx = findPreviousMarkerIndex(ref);
      if (idx === -1) return;
      video.currentTime = markers[idx];
      const pct = (video.currentTime / video.duration) * 100;
      seekBar.value = pct;
    });

    markerRemoveBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (!markers || markers.length === 0) return;
      if (!video || !isFinite(video.duration)) return;
      const ref = Number(video.currentTime || 0);
      const idx = findPreviousMarkerIndex(ref);
      if (idx === -1) {
        return;
      }
      markers.splice(idx, 1);
      renderMarkers();

      // 自動保存: 削除後すぐに保存
      try {
        if (currentHistoryId != null) {
          const normalized = Array.isArray(markers) ? markers.map(x=>Number(x)).filter(x=>isFinite(x)) : [];
          updateEntryMarkers(currentHistoryId, normalized).catch(err => console.warn('マーカー自動保存失敗', err));
        }
      } catch (err) { console.warn('marker remove save err', err); }
    });

    function repositionMarkerLayer(){
      renderMarkers();
    }

    function formatTimeForLabel(sec){
      if (!isFinite(sec)) return '0:00';
      return (function(realSec){
        if (!isFinite(realSec)) return '0:00';
        const ss = Math.floor(realSec % 60).toString().padStart(2,'0');
        const mm = Math.floor(realSec / 60).toString();
        return `${mm}:${ss}`;
      })(sec);
    }

    video.addEventListener('loadeddata', () => { renderMarkers(); });
    video.addEventListener('seeked', () => { renderMarkers(); });
    window.addEventListener('resize', () => { renderMarkers(); });

    /**
    * 以下は履歴保存処理（saveFileToHistory）です。
    * 既存の挙動を極力変えずに、ファイル(blob)を IndexedDB に保存する仕様はそのまま維持しています。
    * （サムネイル生成のみ削除済み）
    */
    async function saveFileToHistory(file){
      try{
        const db = await openDB();

        // --- 既存チェック（readonly） ---
        try {
          const txr = db.transaction(STORE_NAME, 'readonly');
          const storer = txr.objectStore(STORE_NAME);
          const all = await getAllFromStore(storer);
          try { await waitForTransactionComplete(txr); } catch(e){}
          const match = all.find(item => item.name === file.name && item.size === file.size && item.lastModified === file.lastModified);
          if (match) {
            // 更新 (createdAt) は readwrite で行う
            const txu = db.transaction(STORE_NAME, 'readwrite');
            const storeu = txu.objectStore(STORE_NAME);
            match.createdAt = Date.now();
            // migrate legacy categoryId -> categoryIds
            if (match.hasOwnProperty('categoryId') && !match.hasOwnProperty('categoryIds')) {
              match.categoryIds = match.categoryId ? [match.categoryId] : [];
              delete match.categoryId;
            }
            storeu.put(match);
            await waitForTransactionComplete(txu);
            // トリムはバックグラウンドで行う（await しても良い）
            trimHistoryLimit(db).catch(()=>{});
            return match.id;
          }
        } catch (e) {
          // 既存チェック失敗しても保存自体を試みる（ログだけ）
          console.warn('既存チェックに失敗しました（続行します）', e);
        }

        // --- 新規追加（readwrite） ---
        // 現在選択中のカテゴリを取得（"全て" の場合は未分類にする）
        const selCat = (categorySelect && categorySelect.value) ? categorySelect.value : ALL_ID;
        const assignCatArr = (selCat === ALL_ID || selCat === UNCATEGORIZED_ID) ? [] : [selCat];

        const entry = {
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified || 0,
          blob: file, // ファイルオブジェクトをそのまま保存（より互換性あり）
          createdAt: Date.now(),
          note: '', // 新規: 補足フィールドを追加（空文字で初期化）
          categoryIds: assignCatArr, // 複数対応: 空配列=未分類
          markers: [] // 新規: マーカー情報をここで保持（ファイルごと）
        };

        try {
          const tx = db.transaction(STORE_NAME, 'readwrite');
          const store = tx.objectStore(STORE_NAME);
          const addReq = store.add(entry);
          const id = await promisifyRequest(addReq);
          await waitForTransactionComplete(tx);
          // trim を同期的に実行（非致命的）
          await trimHistoryLimit(db);
          return id;
        } catch (err) {
          console.warn('最初の追加でエラー', err);
          // QuotaExceededError 等で失敗した場合は古いアイテムを削除して再試行
          if (err && (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED' || err.code === 22)) {
            try {
              // 古いものをいくつか削除して再挑戦
              const txr2 = db.transaction(STORE_NAME, 'readwrite');
              const store2 = txr2.objectStore(STORE_NAME);
              const all = await getAllFromStore(store2);
              const sorted = all.sort((a,b)=>a.createdAt - b.createdAt);
              // 古いものを 3 件まで削除
              const remove = sorted.slice(0, Math.min(3, sorted.length));
              for (const it of remove) store2.delete(it.id);
              await waitForTransactionComplete(txr2);
            } catch (cleanupErr) {
              console.warn('クリーンアップ中にエラー', cleanupErr);
            }
            // blob を null にして保存（容量を節約）
            try {
              const tx2 = db.transaction(STORE_NAME, 'readwrite');
              const store2 = tx2.objectStore(STORE_NAME);
              const entrySmall = Object.assign({}, entry, { blob: null });
              const addReq2 = store2.add(entrySmall);
              const id2 = await promisifyRequest(addReq2);
              await waitForTransactionComplete(tx2);
              await trimHistoryLimit(db);
              return id2;
            } catch (finalErr) {
              console.warn('最終的な追加にも失敗しました', finalErr);
              return null;
            }
          } else {
            // その他のエラー: 可能なら blob を外して保存
            try {
              const tx3 = db.transaction(STORE_NAME, 'readwrite');
              const store3 = tx3.objectStore(STORE_NAME);
              const entrySmall = Object.assign({}, entry, { blob: null });
              const addReq3 = store3.add(entrySmall);
              const id3 = await promisifyRequest(addReq3);
              await waitForTransactionComplete(tx3);
              await trimHistoryLimit(db);
              return id3;
            } catch (err2) {
              console.warn('blob を外しても保存失敗', err2);
              return null;
            }
          }
        }
      }catch(err){ console.warn('保存に失敗しました', err); return null; }
    }

  </script>
</body>
</html>
